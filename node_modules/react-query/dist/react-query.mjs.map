{"version":3,"file":"react-query.mjs","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../src/core/types.ts","../src/core/utils.ts","../src/core/config.ts","../src/core/notifyManager.ts","../src/core/queryObserver.ts","../src/core/query.ts","../src/core/queryCache.ts","../src/core/setFocusHandler.ts","../src/core/setOnlineHandler.ts","../src/react/reactBatchedUpdates.ts","../src/react/ReactQueryCacheProvider.tsx","../src/react/ReactQueryConfigProvider.tsx","../src/react/ReactQueryErrorResetBoundary.tsx","../src/react/utils.ts","../src/react/useIsFetching.ts","../src/react/useMutation.ts","../src/react/useBaseQuery.ts","../src/react/useQuery.ts","../src/react/usePaginatedQuery.ts","../src/react/useInfiniteQuery.ts","../src/index.ts"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import type { FetchMoreOptions, RefetchOptions } from './query'\nimport type { QueryCache } from './queryCache'\n\nexport type QueryKey =\n  | boolean\n  | null\n  | number\n  | object\n  | string\n  | undefined\n  | { [key: number]: QueryKey }\n  | { [key: string]: QueryKey }\n  | readonly QueryKey[]\n\nexport type ArrayQueryKey = QueryKey[]\n\nexport type QueryFunction<TResult> = (\n  ...args: any[]\n) => TResult | Promise<TResult>\n\nexport type TypedQueryFunction<\n  TResult,\n  TArgs extends TypedQueryFunctionArgs = TypedQueryFunctionArgs\n> = (...args: TArgs) => TResult | Promise<TResult>\n\nexport type TypedQueryFunctionArgs = readonly [unknown, ...unknown[]]\n\nexport type InitialDataFunction<TResult> = () => TResult | undefined\nexport type PlaceholderDataFunction<TResult> = () => TResult | undefined\n\nexport type InitialStaleFunction = () => boolean\n\nexport type QueryKeySerializerFunction = (\n  queryKey: QueryKey\n) => [string, QueryKey[]]\n\nexport interface BaseQueryConfig<TResult, TError = unknown, TData = TResult> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: boolean | number | ((failureCount: number, error: TError) => boolean)\n  retryDelay?: number | ((retryAttempt: number) => number)\n  cacheTime?: number\n  isDataEqual?: (oldData: unknown, newData: unknown) => boolean\n  queryFn?: QueryFunction<TData>\n  queryKey?: QueryKey\n  queryKeySerializerFn?: QueryKeySerializerFunction\n  queryFnParamsFilter?: (args: ArrayQueryKey) => ArrayQueryKey\n  initialData?: TResult | InitialDataFunction<TResult>\n  placeholderData?: TResult | InitialDataFunction<TResult>\n  infinite?: true\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Defaults to `true`.\n   */\n  structuralSharing?: boolean\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `canFetchMore`.\n   */\n  getFetchMore?: (lastPage: TData, allPages: TData[]) => unknown\n}\n\nexport interface QueryObserverConfig<\n  TResult,\n  TError = unknown,\n  TData = TResult\n> extends BaseQueryConfig<TResult, TError, TData> {\n  /**\n   * Set this to `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Defaults to `true`.\n   */\n  enabled?: boolean | unknown\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be stale.\n   */\n  staleTime?: number\n  /**\n   * If set, this will mark any `initialData` provided as stale and will likely cause it to be refetched on mount.\n   * If a function is passed, it will be called only when appropriate to resolve the `initialStale` value.\n   * This can be useful if your `initialStale` value is costly to calculate.\n   */\n  initialStale?: boolean | InitialStaleFunction\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * Defaults to `false`.\n   */\n  refetchInterval?: number | false\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?: boolean | 'always'\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * Defaults to `true`.\n   */\n  refetchOnReconnect?: boolean | 'always'\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetches.\n   * If set to `'always'`, the query will always refetch on mount.\n   * Defaults to `true`.\n   */\n  refetchOnMount?: boolean | 'always'\n  /**\n   * Set this to `true` to always fetch when the component mounts (regardless of staleness).\n   * Defaults to `false`.\n   */\n  forceFetchOnMount?: boolean\n  /**\n   * Whether a change to the query status should re-render a component.\n   * If set to `false`, the component will only re-render when the actual `data` or `error` changes.\n   * Defaults to `true`.\n   */\n  notifyOnStatusChange?: boolean\n  /**\n   * This callback will fire any time the query successfully fetches new data.\n   */\n  onSuccess?: (data: TResult) => void\n  /**\n   * This callback will fire if the query encounters an error and will be passed the error.\n   */\n  onError?: (err: TError) => void\n  /**\n   * This callback will fire any time the query is either successfully fetched or errors and be passed either the data or error.\n   */\n  onSettled?: (data: TResult | undefined, error: TError | null) => void\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * Defaults to `false`.\n   */\n  useErrorBoundary?: boolean\n  /**\n   * If set to `true`, the query will suspend when `status === 'loading'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * Set this to `true` to keep the previous `data` when fetching based on a new query key.\n   * Defaults to `false`.\n   */\n  keepPreviousData?: boolean\n}\n\nexport interface QueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface PaginatedQueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface InfiniteQueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult[], TError, TResult> {}\n\nexport interface ResolvedQueryConfig<TResult, TError = unknown>\n  extends QueryConfig<TResult, TError> {\n  cacheTime: number\n  queryCache: QueryCache\n  queryFn: QueryFunction<TResult>\n  queryHash: string\n  queryKey: ArrayQueryKey\n  queryKeySerializerFn: QueryKeySerializerFunction\n  staleTime: number\n}\n\nexport type IsFetchingMoreValue = 'previous' | 'next' | false\n\nexport enum QueryStatus {\n  Idle = 'idle',\n  Loading = 'loading',\n  Error = 'error',\n  Success = 'success',\n}\n\nexport interface QueryResultBase<TResult, TError = unknown> {\n  canFetchMore: boolean | undefined\n  clear: () => void\n  data: TResult | undefined\n  error: TError | null\n  failureCount: number\n  fetchMore: (\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ) => Promise<TResult | undefined>\n  isError: boolean\n  isFetched: boolean\n  isFetchedAfterMount: boolean\n  isFetching: boolean\n  isFetchingMore?: IsFetchingMoreValue\n  isIdle: boolean\n  isInitialData: boolean\n  isLoading: boolean\n  isPreviousData: boolean\n  isPlaceholderData: boolean\n  isStale: boolean\n  isSuccess: boolean\n  refetch: (options?: RefetchOptions) => Promise<TResult | undefined>\n  remove: () => void\n  status: QueryStatus\n  updatedAt: number\n}\n\nexport interface QueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {}\n\nexport interface PaginatedQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {\n  resolvedData: TResult | undefined\n  latestData: TResult | undefined\n}\n\nexport interface InfiniteQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult[], TError> {}\n\nexport interface MutateConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> {\n  onSuccess?: (data: TResult, variables: TVariables) => Promise<unknown> | void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    snapshotValue: TSnapshot\n  ) => Promise<unknown> | void\n  onSettled?: (\n    data: undefined | TResult,\n    error: TError | null,\n    variables: TVariables,\n    snapshotValue?: TSnapshot\n  ) => Promise<unknown> | void\n  throwOnError?: boolean\n}\n\nexport interface MutationConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutateConfig<TResult, TError, TVariables, TSnapshot> {\n  onMutate?: (variables: TVariables) => Promise<TSnapshot> | TSnapshot\n  useErrorBoundary?: boolean\n  suspense?: boolean\n  /**\n   * By default the query cache from the context is used, but a different cache can be specified.\n   */\n  queryCache?: QueryCache\n}\n\nexport type MutationFunction<TResult, TVariables = unknown> = (\n  variables: TVariables\n) => Promise<TResult>\n\nexport type MutateFunction<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> = (\n  variables?: TVariables,\n  config?: MutateConfig<TResult, TError, TVariables, TSnapshot>\n) => Promise<TResult | undefined>\n\nexport type MutationResultPair<TResult, TError, TVariables, TSnapshot> = [\n  MutateFunction<TResult, TError, TVariables, TSnapshot>,\n  MutationResult<TResult, TError>\n]\n\nexport interface MutationResult<TResult, TError = unknown> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n  reset: () => void\n}\n\nexport interface ReactQueryConfig<TResult = unknown, TError = unknown> {\n  queries?: ReactQueryQueriesConfig<TResult, TError>\n  shared?: ReactQuerySharedConfig\n  mutations?: ReactQueryMutationsConfig<TResult, TError>\n}\n\nexport interface ReactQuerySharedConfig {\n  suspense?: boolean\n}\n\nexport interface ReactQueryQueriesConfig<TResult, TError>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface ReactQueryMutationsConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutationConfig<TResult, TError, TVariables, TSnapshot> {}\n","import { QueryConfig, QueryStatus, QueryKey, QueryFunction } from './types'\n\n// TYPES\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\ntype ConsoleFunction = (...args: any[]) => void\n\nexport interface ConsoleObject {\n  log: ConsoleFunction\n  warn: ConsoleFunction\n  error: ConsoleFunction\n}\n\ninterface Cancelable {\n  cancel(): void\n}\n\nexport class CancelledError {\n  silent?: boolean\n  constructor(silent?: boolean) {\n    this.silent = silent\n  }\n}\n\n// UTILS\n\nlet _uid = 0\nexport function uid(): number {\n  return _uid++\n}\n\nexport const isServer = typeof window === 'undefined'\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport let Console: ConsoleObject = console || {\n  error: noop,\n  warn: noop,\n  log: noop,\n}\n\nexport function setConsole(c: ConsoleObject) {\n  Console = c\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nfunction stableStringifyReplacer(_key: string, value: any): unknown {\n  if (typeof value === 'function') {\n    throw new Error()\n  }\n\n  if (isPlainObject(value)) {\n    return Object.keys(value)\n      .sort()\n      .reduce((result, key) => {\n        result[key] = value[key]\n        return result\n      }, {} as any)\n  }\n\n  return value\n}\n\nexport function stableStringify(value: any): string {\n  return JSON.stringify(value, stableStringifyReplacer)\n}\n\nexport function deepIncludes(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isValidTimeout(value: any): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function isDocumentVisible(): boolean {\n  // document global can be unavailable in react native\n  if (typeof document === 'undefined') {\n    return true\n  }\n  return [undefined, 'visible', 'prerender'].includes(document.visibilityState)\n}\n\nexport function isOnline(): boolean {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs<TResult, TError, TOptions = undefined>(\n  arg1: any,\n  arg2?: any,\n  arg3?: any,\n  arg4?: any\n): [QueryKey, QueryConfig<TResult, TError>, TOptions] {\n  let queryKey: QueryKey\n  let queryFn: QueryFunction<TResult> | undefined\n  let config: QueryConfig<TResult, TError> | undefined\n  let options: TOptions\n\n  if (isPlainObject(arg1)) {\n    queryKey = arg1.queryKey\n    queryFn = arg1.queryFn\n    config = arg1.config\n    options = arg2\n  } else if (isPlainObject(arg2)) {\n    queryKey = arg1\n    config = arg2\n    options = arg3\n  } else {\n    queryKey = arg1\n    queryFn = arg2\n    config = arg3\n    options = arg4\n  }\n\n  config = config || {}\n\n  if (queryFn) {\n    config = { ...config, queryFn }\n  }\n\n  return [queryKey, config, options]\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = Array.isArray(a) && Array.isArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isCancelable(value: any): value is Cancelable {\n  return typeof value?.cancel === 'function'\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function getStatusProps<T extends QueryStatus>(status: T) {\n  return {\n    status,\n    isLoading: status === QueryStatus.Loading,\n    isSuccess: status === QueryStatus.Success,\n    isError: status === QueryStatus.Error,\n    isIdle: status === QueryStatus.Idle,\n  }\n}\n\nexport function createSetHandler(fn: () => void) {\n  let removePreviousHandler: (() => void) | void\n  return (callback: (handler: () => void) => void) => {\n    // Unsub the old handler\n    if (removePreviousHandler) {\n      removePreviousHandler()\n    }\n    // Sub the new handler\n    removePreviousHandler = callback(fn)\n  }\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void): void {\n  Promise.resolve()\n    .then(callback)\n    .catch(error =>\n      setTimeout(() => {\n        throw error\n      })\n    )\n}\n\ntype BatchUpdateFunction = (callback: () => void) => void\n\n// Default to a dummy \"batch\" implementation that just runs the callback\nlet batchedUpdates: BatchUpdateFunction = (callback: () => void) => {\n  callback()\n}\n\n// Allow injecting another batching function later\nexport function setBatchedUpdates(fn: BatchUpdateFunction) {\n  batchedUpdates = fn\n}\n\n// Supply a getter just to skip dealing with ESM bindings\nexport function getBatchedUpdates(): BatchUpdateFunction {\n  return batchedUpdates\n}\n","import { stableStringify } from './utils'\nimport type {\n  ArrayQueryKey,\n  MutationConfig,\n  QueryConfig,\n  QueryKey,\n  QueryKeySerializerFunction,\n  ReactQueryConfig,\n  ResolvedQueryConfig,\n} from './types'\nimport type { QueryCache } from './queryCache'\n\n// TYPES\n\nexport interface ReactQueryConfigRef {\n  current: ReactQueryConfig\n}\n\n// CONFIG\n\nexport const defaultQueryKeySerializerFn: QueryKeySerializerFunction = (\n  queryKey: QueryKey\n): [string, ArrayQueryKey] => {\n  try {\n    let arrayQueryKey: ArrayQueryKey = Array.isArray(queryKey)\n      ? queryKey\n      : [queryKey]\n    const queryHash = stableStringify(arrayQueryKey)\n    arrayQueryKey = JSON.parse(queryHash)\n    return [queryHash, arrayQueryKey]\n  } catch {\n    throw new Error('A valid query key is required!')\n  }\n}\n\n/**\n * Config merging strategy\n *\n * When using hooks the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the hook query cache.\n * 3. Combined defaults from any config providers in the tree.\n * 4. Query/mutation config provided to the hook.\n *\n * When using a query cache directly the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the query cache.\n * 3. Query/mutation config provided to the query cache method.\n */\nexport const DEFAULT_CONFIG: ReactQueryConfig = {\n  queries: {\n    cacheTime: 5 * 60 * 1000,\n    enabled: true,\n    notifyOnStatusChange: true,\n    queryFn: () => Promise.reject(),\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    refetchOnMount: true,\n    refetchOnReconnect: true,\n    refetchOnWindowFocus: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    structuralSharing: true,\n  },\n}\n\nexport function getDefaultReactQueryConfig() {\n  return {\n    queries: { ...DEFAULT_CONFIG.queries },\n    mutations: { ...DEFAULT_CONFIG.mutations },\n  }\n}\n\nexport function mergeReactQueryConfigs(\n  a: ReactQueryConfig,\n  b: ReactQueryConfig\n): ReactQueryConfig {\n  return {\n    shared: {\n      ...a.shared,\n      ...b.shared,\n    },\n    queries: {\n      ...a.queries,\n      ...b.queries,\n    },\n    mutations: {\n      ...a.mutations,\n      ...b.mutations,\n    },\n  }\n}\n\nexport function getResolvedQueryConfig<TResult, TError>(\n  queryCache: QueryCache,\n  queryKey: QueryKey,\n  contextConfig?: ReactQueryConfig,\n  config?: QueryConfig<TResult, TError>\n): ResolvedQueryConfig<TResult, TError> {\n  const queryCacheConfig = queryCache.getDefaultConfig()\n\n  const resolvedConfig = {\n    ...DEFAULT_CONFIG.queries,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.queries,\n    ...contextConfig?.shared,\n    ...contextConfig?.queries,\n    ...config,\n  } as ResolvedQueryConfig<TResult, TError>\n\n  const result = resolvedConfig.queryKeySerializerFn(queryKey)\n\n  resolvedConfig.queryCache = queryCache\n  resolvedConfig.queryHash = result[0]\n  resolvedConfig.queryKey = result[1]\n\n  return resolvedConfig\n}\n\nexport function isResolvedQueryConfig<TResult, TError>(\n  config: any\n): config is ResolvedQueryConfig<TResult, TError> {\n  return Boolean(config.queryHash)\n}\n\nexport function getResolvedMutationConfig<\n  TResult,\n  TError,\n  TVariables,\n  TSnapshot\n>(\n  queryCache: QueryCache,\n  contextConfig?: ReactQueryConfig,\n  config?: MutationConfig<TResult, TError, TVariables, TSnapshot>\n): MutationConfig<TResult, TError, TVariables, TSnapshot> {\n  const queryCacheConfig = queryCache.getDefaultConfig()\n  return {\n    ...DEFAULT_CONFIG.mutations,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.mutations,\n    ...contextConfig?.shared,\n    ...contextConfig?.mutations,\n    ...config,\n  } as MutationConfig<TResult, TError, TVariables, TSnapshot>\n}\n","import { getBatchedUpdates, scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\n// CLASS\n\nexport class NotifyManager {\n  private queue: NotifyCallback[]\n  private transactions: number\n\n  constructor() {\n    this.queue = []\n    this.transactions = 0\n  }\n\n  batch<T>(callback: () => T): T {\n    this.transactions++\n    const result = callback()\n    this.transactions--\n    if (!this.transactions) {\n      this.flush()\n    }\n    return result\n  }\n\n  schedule(notify: NotifyCallback): void {\n    if (this.transactions) {\n      this.queue.push(notify)\n    } else {\n      scheduleMicrotask(() => {\n        notify()\n      })\n    }\n  }\n\n  flush(): void {\n    const queue = this.queue\n    this.queue = []\n    if (queue.length) {\n      scheduleMicrotask(() => {\n        const batchedUpdates = getBatchedUpdates()\n        batchedUpdates(() => {\n          queue.forEach(notify => {\n            notify()\n          })\n        })\n      })\n    }\n  }\n}\n\n// SINGLETON\n\nexport const notifyManager = new NotifyManager()\n","import {\n  getStatusProps,\n  isDocumentVisible,\n  isServer,\n  isValidTimeout,\n  noop,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  QueryConfig,\n  QueryResult,\n  ResolvedQueryConfig,\n  PlaceholderDataFunction,\n} from './types'\nimport { QueryStatus } from './types'\nimport type { Query, Action, FetchMoreOptions, RefetchOptions } from './query'\nimport { DEFAULT_CONFIG, isResolvedQueryConfig } from './config'\n\nexport type UpdateListener<TResult, TError> = (\n  result: QueryResult<TResult, TError>\n) => void\n\ninterface NotifyOptions {\n  globalListeners?: boolean\n  listener?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport class QueryObserver<TResult, TError> {\n  config: ResolvedQueryConfig<TResult, TError>\n\n  private currentQuery!: Query<TResult, TError>\n  private currentResult!: QueryResult<TResult, TError>\n  private previousQueryResult?: QueryResult<TResult, TError>\n  private listener?: UpdateListener<TResult, TError>\n  private isStale: boolean\n  private initialUpdateCount: number\n  private staleTimeoutId?: number\n  private refetchIntervalId?: number\n\n  constructor(config: ResolvedQueryConfig<TResult, TError>) {\n    this.config = config\n    this.isStale = true\n    this.initialUpdateCount = 0\n\n    // Bind exposed methods\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n    this.fetchMore = this.fetchMore.bind(this)\n    this.unsubscribe = this.unsubscribe.bind(this)\n\n    // Subscribe to the query\n    this.updateQuery()\n  }\n\n  subscribe(listener?: UpdateListener<TResult, TError>): () => void {\n    this.listener = listener || noop\n    this.currentQuery.subscribeObserver(this)\n\n    if (\n      this.config.enabled &&\n      (this.config.forceFetchOnMount || this.config.refetchOnMount === 'always')\n    ) {\n      this.fetch()\n    } else {\n      this.optionalFetch()\n    }\n\n    this.updateTimers()\n\n    return this.unsubscribe\n  }\n\n  unsubscribe(): void {\n    this.listener = undefined\n    this.clearTimers()\n    this.currentQuery.unsubscribeObserver(this)\n  }\n\n  updateConfig(\n    config: QueryConfig<TResult, TError> | ResolvedQueryConfig<TResult, TError>\n  ): void {\n    const prevConfig = this.config\n    const prevQuery = this.currentQuery\n\n    this.config = isResolvedQueryConfig(config)\n      ? config\n      : this.config.queryCache.getResolvedQueryConfig(\n          this.config.queryKey,\n          config\n        )\n\n    this.updateQuery()\n\n    // Take no further actions if there is no subscriber\n    if (!this.listener) {\n      return\n    }\n\n    // If we subscribed to a new query, optionally fetch and update refetch\n    if (this.currentQuery !== prevQuery) {\n      this.optionalFetch()\n      this.updateTimers()\n      return\n    }\n\n    // Optionally fetch if the query became enabled\n    if (config.enabled && !prevConfig.enabled) {\n      this.optionalFetch()\n    }\n\n    // Update stale interval if needed\n    if (\n      config.enabled !== prevConfig.enabled ||\n      config.staleTime !== prevConfig.staleTime\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    // Update refetch interval if needed\n    if (\n      config.enabled !== prevConfig.enabled ||\n      config.refetchInterval !== prevConfig.refetchInterval\n    ) {\n      this.updateRefetchInterval()\n    }\n  }\n\n  getCurrentQuery(): Query<TResult, TError> {\n    return this.currentQuery\n  }\n\n  getCurrentResult(): QueryResult<TResult, TError> {\n    return this.currentResult\n  }\n\n  /**\n   * @deprecated\n   */\n  clear(): void {\n    this.remove()\n  }\n\n  remove(): void {\n    this.currentQuery.remove()\n  }\n\n  refetch(options?: RefetchOptions): Promise<TResult | undefined> {\n    return this.currentQuery.refetch(options, this.config)\n  }\n\n  fetchMore(\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ): Promise<TResult | undefined> {\n    return this.currentQuery\n      .fetchMore(fetchMoreVariable, options, this.config)\n      .catch(noop)\n  }\n\n  fetch(): Promise<TResult | undefined> {\n    // Never try to fetch if no query function has been set\n    if (this.config.queryFn === DEFAULT_CONFIG.queries?.queryFn) {\n      return Promise.resolve(this.currentResult.data)\n    }\n\n    return this.currentQuery.fetch(undefined, this.config).catch(noop)\n  }\n\n  private optionalFetch(): void {\n    if (\n      this.config.enabled && // Only fetch if enabled\n      this.isStale && // Only fetch if stale\n      !(this.config.suspense && this.currentResult.isFetched) && // Don't refetch if in suspense mode and the data is already fetched\n      (this.config.refetchOnMount || this.currentQuery.observers.length === 1)\n    ) {\n      this.fetch()\n    }\n  }\n\n  private updateStaleTimeout(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearStaleTimeout()\n\n    if (this.isStale || !isValidTimeout(this.config.staleTime)) {\n      return\n    }\n\n    const timeElapsed = Date.now() - this.currentResult.updatedAt\n    const timeUntilStale = this.config.staleTime - timeElapsed + 1\n    const timeout = Math.max(timeUntilStale, 0)\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.isStale) {\n        this.isStale = true\n        this.updateResult()\n        this.notify({ listener: true, globalListeners: true })\n      }\n    }, timeout)\n  }\n\n  private updateRefetchInterval(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearRefetchInterval()\n\n    if (!this.config.enabled || !isValidTimeout(this.config.refetchInterval)) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.config.refetchIntervalInBackground || isDocumentVisible()) {\n        this.fetch()\n      }\n    }, this.config.refetchInterval)\n  }\n\n  updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval()\n  }\n\n  clearTimers(): void {\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n  }\n\n  private clearStaleTimeout(): void {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId)\n      this.staleTimeoutId = undefined\n    }\n  }\n\n  private clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  private updateResult(): void {\n    const { state } = this.currentQuery\n    let { data, status, updatedAt } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n\n    // Keep previous data if needed\n    if (\n      this.config.keepPreviousData &&\n      state.isInitialData &&\n      this.previousQueryResult?.isSuccess\n    ) {\n      data = this.previousQueryResult.data\n      updatedAt = this.previousQueryResult.updatedAt\n      status = this.previousQueryResult.status\n      isPreviousData = true\n    }\n\n    if (status === 'loading' && this.config.placeholderData) {\n      const placeholderData =\n        typeof this.config.placeholderData === 'function'\n          ? (this.config.placeholderData as PlaceholderDataFunction<TResult>)()\n          : this.config.placeholderData\n\n      if (typeof placeholderData !== 'undefined') {\n        status = QueryStatus.Success\n        data = placeholderData\n        isPlaceholderData = true\n      }\n    }\n\n    this.currentResult = {\n      ...getStatusProps(status),\n      canFetchMore: state.canFetchMore,\n      clear: this.remove,\n      data,\n      error: state.error,\n      failureCount: state.failureCount,\n      fetchMore: this.fetchMore,\n      isFetched: state.updateCount > 0,\n      isFetchedAfterMount: state.updateCount > this.initialUpdateCount,\n      isFetching: state.isFetching,\n      isFetchingMore: state.isFetchingMore,\n      isInitialData: state.isInitialData,\n      isPreviousData,\n      isPlaceholderData,\n      isStale: this.isStale,\n      refetch: this.refetch,\n      remove: this.remove,\n      updatedAt,\n    }\n  }\n\n  private updateQuery(): void {\n    const config = this.config\n    const prevQuery = this.currentQuery\n\n    let query = config.queryCache.getQueryByHash<TResult, TError>(\n      config.queryHash\n    )\n\n    if (!query) {\n      query = config.queryCache.createQuery(config)\n    }\n\n    if (query === prevQuery) {\n      return\n    }\n\n    this.previousQueryResult = this.currentResult\n    this.currentQuery = query\n    this.initialUpdateCount = query.state.updateCount\n\n    // Update stale state on query switch\n    if (query.state.isInitialData) {\n      if (config.keepPreviousData && prevQuery) {\n        this.isStale = true\n      } else if (typeof config.initialStale === 'function') {\n        this.isStale = config.initialStale()\n      } else if (typeof config.initialStale === 'boolean') {\n        this.isStale = config.initialStale\n      } else {\n        this.isStale = typeof query.state.data === 'undefined'\n      }\n    } else {\n      this.isStale = query.isStaleByTime(config.staleTime)\n    }\n\n    this.updateResult()\n\n    if (this.listener) {\n      prevQuery?.unsubscribeObserver(this)\n      this.currentQuery.subscribeObserver(this)\n    }\n  }\n\n  onQueryUpdate(action: Action<TResult, TError>): void {\n    const { config } = this\n    const { type } = action\n\n    // Update stale state on success, error or invalidation\n    if (type === 2 || type === 3 || type === 4) {\n      this.isStale = this.currentQuery.isStaleByTime(config.staleTime)\n    }\n\n    // Store current result and get new result\n    const prevResult = this.currentResult\n    this.updateResult()\n    const currentResult = this.currentResult\n\n    // Update timers on success, error or invalidation\n    if (type === 2 || type === 3 || type === 4) {\n      this.updateTimers()\n    }\n\n    // Do not notify if the query was invalidated but the stale state did not changed\n    if (type === 4 && currentResult.isStale === prevResult.isStale) {\n      return\n    }\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {}\n\n    if (type === 2) {\n      notifyOptions.onSuccess = true\n    } else if (type === 3) {\n      notifyOptions.onError = true\n    }\n\n    if (\n      // Always notify if notifyOnStatusChange is set\n      config.notifyOnStatusChange ||\n      // Otherwise only notify on data or error change\n      currentResult.data !== prevResult.data ||\n      currentResult.error !== prevResult.error\n    ) {\n      notifyOptions.listener = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  private notify(options: NotifyOptions): void {\n    const { config, currentResult, currentQuery, listener } = this\n    const { onSuccess, onSettled, onError } = config\n\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (options.onSuccess) {\n        if (onSuccess) {\n          notifyManager.schedule(() => {\n            onSuccess(currentResult.data!)\n          })\n        }\n        if (onSettled) {\n          notifyManager.schedule(() => {\n            onSettled(currentResult.data!, null)\n          })\n        }\n      } else if (options.onError) {\n        if (onError) {\n          notifyManager.schedule(() => {\n            onError(currentResult.error!)\n          })\n        }\n        if (onSettled) {\n          notifyManager.schedule(() => {\n            onSettled(undefined, currentResult.error!)\n          })\n        }\n      }\n\n      // Then trigger the listener\n      if (options.listener && listener) {\n        notifyManager.schedule(() => {\n          listener(currentResult)\n        })\n      }\n\n      // Then the global listeners\n      if (options.globalListeners) {\n        config.queryCache.notifyGlobalListeners(currentQuery)\n      }\n    })\n  }\n}\n","import {\n  CancelledError,\n  Console,\n  Updater,\n  functionalUpdate,\n  isCancelable,\n  isCancelledError,\n  isDocumentVisible,\n  isOnline,\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceEqualDeep,\n  sleep,\n} from './utils'\nimport {\n  ArrayQueryKey,\n  InitialDataFunction,\n  IsFetchingMoreValue,\n  QueryFunction,\n  QueryStatus,\n  ResolvedQueryConfig,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport { QueryObserver, UpdateListener } from './queryObserver'\nimport { notifyManager } from './notifyManager'\n\n// TYPES\n\nexport interface QueryState<TResult, TError> {\n  canFetchMore?: boolean\n  data?: TResult\n  error: TError | null\n  failureCount: number\n  isFetching: boolean\n  isFetchingMore: IsFetchingMoreValue\n  isInitialData: boolean\n  isInvalidated: boolean\n  status: QueryStatus\n  throwInErrorBoundary?: boolean\n  updateCount: number\n  updatedAt: number\n}\n\ninterface FetchOptions {\n  fetchMore?: FetchMoreOptions\n}\n\nexport interface FetchMoreOptions {\n  fetchMoreVariable?: unknown\n  previous: boolean\n}\n\nexport interface RefetchOptions {\n  throwOnError?: boolean\n}\n\nconst enum ActionType {\n  Failed,\n  Fetch,\n  Success,\n  Error,\n  Invalidate,\n}\n\ninterface SetDataOptions {\n  updatedAt?: number\n}\n\ninterface FailedAction {\n  type: ActionType.Failed\n}\n\ninterface FetchAction {\n  type: ActionType.Fetch\n  isFetchingMore?: IsFetchingMoreValue\n}\n\ninterface SuccessAction<TResult> {\n  type: ActionType.Success\n  data: TResult | undefined\n  canFetchMore?: boolean\n  updatedAt?: number\n}\n\ninterface ErrorAction<TError> {\n  type: ActionType.Error\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: ActionType.Invalidate\n}\n\nexport type Action<TResult, TError> =\n  | ErrorAction<TError>\n  | FailedAction\n  | FetchAction\n  | InvalidateAction\n  | SuccessAction<TResult>\n\n// CLASS\n\nexport class Query<TResult, TError> {\n  queryKey: ArrayQueryKey\n  queryHash: string\n  config: ResolvedQueryConfig<TResult, TError>\n  observers: QueryObserver<TResult, TError>[]\n  state: QueryState<TResult, TError>\n  cacheTime: number\n\n  private queryCache: QueryCache\n  private promise?: Promise<TResult>\n  private gcTimeout?: number\n  private cancelFetch?: (silent?: boolean) => void\n  private continueFetch?: () => void\n  private isTransportCancelable?: boolean\n\n  constructor(config: ResolvedQueryConfig<TResult, TError>) {\n    this.config = config\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.queryCache = config.queryCache\n    this.cacheTime = config.cacheTime\n    this.observers = []\n    this.state = getDefaultState(config)\n    this.scheduleGc()\n  }\n\n  private updateConfig(config: ResolvedQueryConfig<TResult, TError>): void {\n    this.config = config\n    this.cacheTime = Math.max(this.cacheTime, config.cacheTime)\n  }\n\n  private dispatch(action: Action<TResult, TError>): void {\n    this.state = queryReducer(this.state, action)\n\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action)\n      })\n\n      this.queryCache.notifyGlobalListeners(this)\n    })\n  }\n\n  private scheduleGc(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearGcTimeout()\n\n    if (this.observers.length > 0 || !isValidTimeout(this.cacheTime)) {\n      return\n    }\n\n    this.gcTimeout = setTimeout(() => {\n      this.remove()\n    }, this.cacheTime)\n  }\n\n  cancel(silent?: boolean): Promise<undefined> {\n    const promise = this.promise\n\n    if (promise && this.cancelFetch) {\n      this.cancelFetch(silent)\n      return promise.then(noop).catch(noop)\n    }\n\n    return Promise.resolve(undefined)\n  }\n\n  private continue(): void {\n    this.continueFetch?.()\n  }\n\n  private clearTimersObservers(): void {\n    this.observers.forEach(observer => {\n      observer.clearTimers()\n    })\n  }\n\n  private clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout)\n      this.gcTimeout = undefined\n    }\n  }\n\n  setData(\n    updater: Updater<TResult | undefined, TResult>,\n    options?: SetDataOptions\n  ): void {\n    const prevData = this.state.data\n\n    // Get the new data\n    let data: TResult | undefined = functionalUpdate(updater, prevData)\n\n    // Use prev data if an isDataEqual function is defined and returns `true`\n    if (this.config.isDataEqual?.(prevData, data)) {\n      data = prevData\n    } else if (this.config.structuralSharing) {\n      // Structurally share data between prev and new data if needed\n      data = replaceEqualDeep(prevData, data)\n    }\n\n    // Try to determine if more data can be fetched\n    const canFetchMore = hasMorePages(this.config, data)\n\n    // Set data and mark it as cached\n    this.dispatch({\n      type: ActionType.Success,\n      data,\n      canFetchMore,\n      updatedAt: options?.updatedAt,\n    })\n  }\n\n  /**\n   * @deprecated\n   */\n  clear(): void {\n    Console.warn(\n      'react-query: clear() has been deprecated, please use remove() instead'\n    )\n    this.remove()\n  }\n\n  remove(): void {\n    this.queryCache.removeQuery(this)\n  }\n\n  destroy(): void {\n    this.clearGcTimeout()\n    this.clearTimersObservers()\n    this.cancel()\n  }\n\n  isActive(): boolean {\n    return this.observers.some(observer => observer.config.enabled)\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      this.state.status !== QueryStatus.Success ||\n      this.observers.some(observer => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      this.state.status !== QueryStatus.Success ||\n      this.state.updatedAt + staleTime <= Date.now()\n    )\n  }\n\n  onInteraction(type: 'focus' | 'online'): void {\n    // Execute the first observer which is enabled,\n    // stale and wants to refetch on this interaction.\n    const staleObserver = this.observers.find(observer => {\n      const { config } = observer\n      const { isStale } = observer.getCurrentResult()\n      return (\n        config.enabled &&\n        ((type === 'focus' &&\n          (config.refetchOnWindowFocus === 'always' ||\n            (config.refetchOnWindowFocus && isStale))) ||\n          (type === 'online' &&\n            (config.refetchOnReconnect === 'always' ||\n              (config.refetchOnReconnect && isStale))))\n      )\n    })\n\n    if (staleObserver) {\n      staleObserver.fetch()\n    }\n\n    // Continue any paused fetch\n    this.continue()\n  }\n\n  /**\n   * @deprectated\n   */\n  subscribe(\n    listener?: UpdateListener<TResult, TError>\n  ): QueryObserver<TResult, TError> {\n    const observer = new QueryObserver(this.config)\n    observer.subscribe(listener)\n    return observer\n  }\n\n  subscribeObserver(observer: QueryObserver<TResult, TError>): void {\n    this.observers.push(observer)\n\n    // Stop the query from being garbage collected\n    this.clearGcTimeout()\n  }\n\n  unsubscribeObserver(observer: QueryObserver<TResult, TError>): void {\n    this.observers = this.observers.filter(x => x !== observer)\n\n    if (!this.observers.length) {\n      // If the transport layer does not support cancellation\n      // we'll let the query continue so the result can be cached\n      if (this.isTransportCancelable) {\n        this.cancel()\n      }\n\n      this.scheduleGc()\n    }\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: ActionType.Invalidate })\n    }\n  }\n\n  /**\n   * @deprectated\n   */\n  refetch(\n    options?: RefetchOptions,\n    config?: ResolvedQueryConfig<TResult, TError>\n  ): Promise<TResult | undefined> {\n    let promise: Promise<TResult | undefined> = this.fetch(undefined, config)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  /**\n   * @deprectated\n   */\n  fetchMore(\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions,\n    config?: ResolvedQueryConfig<TResult, TError>\n  ): Promise<TResult | undefined> {\n    return this.fetch(\n      {\n        fetchMore: {\n          fetchMoreVariable,\n          previous: options?.previous || false,\n        },\n      },\n      config\n    )\n  }\n\n  async fetch(\n    options?: FetchOptions,\n    config?: ResolvedQueryConfig<TResult, TError>\n  ): Promise<TResult> {\n    if (this.promise) {\n      if (options?.fetchMore && this.state.data) {\n        // Silently cancel current fetch if the user wants to fetch more\n        await this.cancel(true)\n      } else {\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (config) {\n      this.updateConfig(config)\n    }\n\n    config = this.config\n\n    // Get the query function params\n    const filter = config.queryFnParamsFilter\n    const params = filter ? filter(this.queryKey) : this.queryKey\n\n    this.promise = (async () => {\n      try {\n        let data: any\n\n        if (config.infinite) {\n          data = await this.startInfiniteFetch(config, params, options)\n        } else {\n          data = await this.startFetch(config, params, options)\n        }\n\n        // Set success state\n        this.setData(data)\n\n        // Cleanup\n        delete this.promise\n\n        // Return data\n        return data\n      } catch (error) {\n        // Set error state if needed\n        if (!(isCancelledError(error) && error.silent)) {\n          this.dispatch({\n            type: ActionType.Error,\n            error,\n          })\n        }\n\n        // Log error\n        if (!isCancelledError(error)) {\n          Console.error(error)\n        }\n\n        // Cleanup\n        delete this.promise\n\n        // Propagate error\n        throw error\n      }\n    })()\n\n    return this.promise\n  }\n\n  private startFetch(\n    config: ResolvedQueryConfig<TResult, TError>,\n    params: unknown[],\n    _options?: FetchOptions\n  ): Promise<TResult> {\n    // Create function to fetch the data\n    const fetchData = () => config.queryFn(...params)\n\n    // Set to fetching state if not already in it\n    if (!this.state.isFetching) {\n      this.dispatch({ type: ActionType.Fetch })\n    }\n\n    // Try to fetch the data\n    return this.tryFetchData(config, fetchData)\n  }\n\n  private startInfiniteFetch(\n    config: ResolvedQueryConfig<TResult, TError>,\n    params: unknown[],\n    options?: FetchOptions\n  ): Promise<TResult[]> {\n    const fetchMore = options?.fetchMore\n    const { previous, fetchMoreVariable } = fetchMore || {}\n    const isFetchingMore = fetchMore ? (previous ? 'previous' : 'next') : false\n    const prevPages: TResult[] = (this.state.data as any) || []\n\n    // Create function to fetch a page\n    const fetchPage = async (\n      pages: TResult[],\n      prepend?: boolean,\n      cursor?: unknown\n    ) => {\n      const lastPage = getLastPage(pages, prepend)\n\n      if (\n        typeof cursor === 'undefined' &&\n        typeof lastPage !== 'undefined' &&\n        config.getFetchMore\n      ) {\n        cursor = config.getFetchMore(lastPage, pages)\n      }\n\n      if (!Boolean(cursor) && typeof lastPage !== 'undefined') {\n        return pages\n      }\n\n      const page = await config.queryFn(...params, cursor)\n\n      return prepend ? [page, ...pages] : [...pages, page]\n    }\n\n    // Create function to fetch the data\n    const fetchData = () => {\n      if (isFetchingMore) {\n        return fetchPage(prevPages, previous, fetchMoreVariable)\n      } else if (!prevPages.length) {\n        return fetchPage([])\n      } else {\n        let promise = fetchPage([])\n        for (let i = 1; i < prevPages.length; i++) {\n          promise = promise.then(fetchPage)\n        }\n        return promise\n      }\n    }\n\n    // Set to fetching state if not already in it\n    if (\n      !this.state.isFetching ||\n      this.state.isFetchingMore !== isFetchingMore\n    ) {\n      this.dispatch({ type: ActionType.Fetch, isFetchingMore })\n    }\n\n    // Try to get the data\n    return this.tryFetchData(config, fetchData)\n  }\n\n  private tryFetchData<T>(\n    config: ResolvedQueryConfig<TResult, TError>,\n    fn: QueryFunction<T>\n  ): Promise<T> {\n    return new Promise<T>((outerResolve, outerReject) => {\n      let resolved = false\n      let continueLoop: () => void\n      let cancelTransport: () => void\n\n      const done = () => {\n        resolved = true\n\n        delete this.cancelFetch\n        delete this.continueFetch\n        delete this.isTransportCancelable\n\n        // End loop if currently paused\n        continueLoop?.()\n      }\n\n      const resolve = (value: any) => {\n        done()\n        outerResolve(value)\n      }\n\n      const reject = (value: any) => {\n        done()\n        outerReject(value)\n      }\n\n      // Create callback to cancel this fetch\n      this.cancelFetch = silent => {\n        reject(new CancelledError(silent))\n        cancelTransport?.()\n      }\n\n      // Create callback to continue this fetch\n      this.continueFetch = () => {\n        continueLoop?.()\n      }\n\n      // Create loop function\n      const run = async () => {\n        try {\n          // Execute query\n          const promiseOrValue = fn()\n\n          // Check if the transport layer support cancellation\n          if (isCancelable(promiseOrValue)) {\n            cancelTransport = () => {\n              try {\n                promiseOrValue.cancel()\n              } catch {}\n            }\n            this.isTransportCancelable = true\n          }\n\n          // Await data\n          resolve(await promiseOrValue)\n        } catch (error) {\n          // Stop if the fetch is already resolved\n          if (resolved) {\n            return\n          }\n\n          // Do we need to retry the request?\n          const { failureCount } = this.state\n          const { retry, retryDelay } = config\n\n          const shouldRetry =\n            retry === true ||\n            failureCount < retry! ||\n            (typeof retry === 'function' && retry(failureCount, error))\n\n          if (!shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error)\n            return\n          }\n\n          // Increase the failureCount\n          this.dispatch({ type: ActionType.Failed })\n\n          // Delay\n          await sleep(functionalUpdate(retryDelay, failureCount) || 0)\n\n          // Pause retry if the document is not visible or when the device is offline\n          if (!isDocumentVisible() || !isOnline()) {\n            await new Promise(continueResolve => {\n              continueLoop = continueResolve\n            })\n          }\n\n          // Try again if not resolved yet\n          if (!resolved) {\n            run()\n          }\n        }\n      }\n\n      // Start loop\n      run()\n    })\n  }\n}\n\nfunction getLastPage<TResult>(pages: TResult[], previous?: boolean): TResult {\n  return previous ? pages[0] : pages[pages.length - 1]\n}\n\nfunction hasMorePages<TResult, TError>(\n  config: ResolvedQueryConfig<TResult, TError>,\n  pages: unknown,\n  previous?: boolean\n): boolean | undefined {\n  if (config.infinite && config.getFetchMore && Array.isArray(pages)) {\n    return Boolean(config.getFetchMore(getLastPage(pages, previous), pages))\n  }\n}\n\nfunction getDefaultState<TResult, TError>(\n  config: ResolvedQueryConfig<TResult, TError>\n): QueryState<TResult, TError> {\n  const data =\n    typeof config.initialData === 'function'\n      ? (config.initialData as InitialDataFunction<TResult>)()\n      : config.initialData\n\n  const status =\n    typeof data !== 'undefined'\n      ? QueryStatus.Success\n      : config.enabled\n      ? QueryStatus.Loading\n      : QueryStatus.Idle\n\n  return {\n    canFetchMore: hasMorePages(config, data),\n    data,\n    error: null,\n    failureCount: 0,\n    isFetching: status === QueryStatus.Loading,\n    isFetchingMore: false,\n    isInitialData: true,\n    isInvalidated: false,\n    status,\n    updateCount: 0,\n    updatedAt: Date.now(),\n  }\n}\n\nexport function queryReducer<TResult, TError>(\n  state: QueryState<TResult, TError>,\n  action: Action<TResult, TError>\n): QueryState<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Failed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case ActionType.Fetch:\n      return {\n        ...state,\n        failureCount: 0,\n        isFetching: true,\n        isFetchingMore: action.isFetchingMore || false,\n        status:\n          typeof state.data !== 'undefined'\n            ? QueryStatus.Success\n            : QueryStatus.Loading,\n      }\n    case ActionType.Success:\n      return {\n        ...state,\n        canFetchMore: action.canFetchMore,\n        data: action.data,\n        error: null,\n        failureCount: 0,\n        isFetching: false,\n        isFetchingMore: false,\n        isInitialData: false,\n        isInvalidated: false,\n        status: QueryStatus.Success,\n        updateCount: state.updateCount + 1,\n        updatedAt: action.updatedAt ?? Date.now(),\n      }\n    case ActionType.Error:\n      return {\n        ...state,\n        error: action.error,\n        failureCount: state.failureCount + 1,\n        isFetching: false,\n        isFetchingMore: false,\n        status: QueryStatus.Error,\n        throwInErrorBoundary: true,\n        updateCount: state.updateCount + 1,\n      }\n    case ActionType.Invalidate:\n      return {\n        ...state,\n        isInvalidated: true,\n      }\n    default:\n      return state\n  }\n}\n","import {\n  Updater,\n  deepIncludes,\n  getQueryArgs,\n  isDocumentVisible,\n  isOnline,\n  isPlainObject,\n  isServer,\n  noop,\n} from './utils'\nimport { getResolvedQueryConfig } from './config'\nimport { Query } from './query'\nimport {\n  QueryConfig,\n  QueryFunction,\n  QueryKey,\n  ReactQueryConfig,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n  ResolvedQueryConfig,\n} from './types'\nimport { notifyManager } from './notifyManager'\nimport { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  frozen?: boolean\n  defaultConfig?: ReactQueryConfig\n}\n\ninterface ClearOptions {\n  notify?: boolean\n}\n\ninterface PrefetchQueryOptions {\n  force?: boolean\n  throwOnError?: boolean\n}\n\ninterface RefetchQueriesOptions extends QueryPredicateOptions {\n  throwOnError?: boolean\n}\n\ninterface InvalidateQueriesOptions extends RefetchQueriesOptions {\n  refetchActive?: boolean\n  refetchInactive?: boolean\n}\n\ninterface QueryPredicateOptions {\n  active?: boolean\n  exact?: boolean\n  stale?: boolean\n}\n\ntype QueryPredicate = QueryKey | QueryPredicateFn | true\n\ntype QueryPredicateFn = (query: Query<unknown, unknown>) => boolean\n\nexport interface FetchQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: QueryConfig<TResult, TError>\n}\n\nexport interface PrefetchQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: QueryConfig<TResult, TError>\n  options?: PrefetchQueryOptions\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any>\n}\n\ntype QueryCacheListener = (\n  cache: QueryCache,\n  query?: Query<unknown, unknown>\n) => void\n\n// CLASS\n\nexport class QueryCache {\n  isFetching: number\n\n  private config: QueryCacheConfig\n  private globalListeners: QueryCacheListener[]\n  private queries: QueryHashMap\n  private queriesArray: Query<any, any>[]\n\n  constructor(config?: QueryCacheConfig) {\n    this.config = config || {}\n    this.globalListeners = []\n    this.queries = {}\n    this.queriesArray = []\n    this.isFetching = 0\n  }\n\n  notifyGlobalListeners(query?: Query<any, any>) {\n    this.isFetching = this.getQueries().reduce(\n      (acc, q) => (q.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    notifyManager.batch(() => {\n      this.globalListeners.forEach(listener => {\n        notifyManager.schedule(() => {\n          listener(this, query)\n        })\n      })\n    })\n  }\n\n  getDefaultConfig() {\n    return this.config.defaultConfig\n  }\n\n  getResolvedQueryConfig<TResult, TError>(\n    queryKey: QueryKey,\n    config?: QueryConfig<TResult, TError>\n  ): ResolvedQueryConfig<TResult, TError> {\n    return getResolvedQueryConfig(this, queryKey, undefined, config)\n  }\n\n  subscribe(listener: QueryCacheListener): () => void {\n    this.globalListeners.push(listener)\n    return () => {\n      this.globalListeners = this.globalListeners.filter(x => x !== listener)\n    }\n  }\n\n  clear(options?: ClearOptions): void {\n    this.removeQueries()\n    if (options?.notify) {\n      this.notifyGlobalListeners()\n    }\n  }\n\n  getQueries<TResult = unknown, TError = unknown>(\n    predicate?: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): Query<TResult, TError>[] {\n    const anyKey = predicate === true || typeof predicate === 'undefined'\n\n    if (anyKey && !options) {\n      return this.queriesArray\n    }\n\n    let predicateFn: QueryPredicateFn\n\n    if (typeof predicate === 'function') {\n      predicateFn = predicate as QueryPredicateFn\n    } else {\n      const { exact, active, stale } = options || {}\n      const resolvedConfig = this.getResolvedQueryConfig(predicate)\n\n      predicateFn = query => {\n        // Check query key if needed\n        if (!anyKey) {\n          if (exact) {\n            // Check if the query key matches exactly\n            if (query.queryHash !== resolvedConfig.queryHash) {\n              return false\n            }\n          } else {\n            // Check if the query key matches partially\n            if (!deepIncludes(query.queryKey, resolvedConfig.queryKey)) {\n              return false\n            }\n          }\n        }\n\n        // Check active state if needed\n        if (typeof active === 'boolean' && query.isActive() !== active) {\n          return false\n        }\n\n        // Check stale state if needed\n        if (typeof stale === 'boolean' && query.isStale() !== stale) {\n          return false\n        }\n\n        return true\n      }\n    }\n\n    return this.queriesArray.filter(predicateFn)\n  }\n\n  getQuery<TResult, TError = unknown>(\n    predicate: QueryPredicate\n  ): Query<TResult, TError> | undefined {\n    return this.getQueries<TResult, TError>(predicate, { exact: true })[0]\n  }\n\n  getQueryByHash<TResult, TError = unknown>(\n    queryHash: string\n  ): Query<TResult, TError> | undefined {\n    return this.queries[queryHash]\n  }\n\n  getQueryData<TResult>(predicate: QueryPredicate): TResult | undefined {\n    return this.getQuery<TResult>(predicate)?.state.data\n  }\n\n  removeQuery(query: Query<any, any>): void {\n    if (this.queries[query.queryHash]) {\n      query.destroy()\n      delete this.queries[query.queryHash]\n      this.queriesArray = this.queriesArray.filter(x => x !== query)\n      this.notifyGlobalListeners(query)\n    }\n  }\n\n  removeQueries(\n    predicate?: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => {\n      this.removeQuery(query)\n    })\n  }\n\n  cancelQueries(\n    predicate?: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => {\n      query.cancel()\n    })\n  }\n\n  /**\n   * @return Promise resolving to an array with the invalidated queries.\n   */\n  invalidateQueries(\n    predicate?: QueryPredicate,\n    options?: InvalidateQueriesOptions\n  ): Promise<Query<unknown, unknown>[]> {\n    const queries = this.getQueries(predicate, options)\n\n    notifyManager.batch(() => {\n      queries.forEach(query => {\n        query.invalidate()\n      })\n    })\n\n    const { refetchActive = true, refetchInactive = false } = options || {}\n\n    if (!refetchInactive && !refetchActive) {\n      return Promise.resolve(queries)\n    }\n\n    const refetchOptions: RefetchQueriesOptions = { ...options }\n\n    if (refetchActive && !refetchInactive) {\n      refetchOptions.active = true\n    } else if (refetchInactive && !refetchActive) {\n      refetchOptions.active = false\n    }\n\n    let promise = this.refetchQueries(predicate, refetchOptions)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(() => queries)\n    }\n\n    return promise.then(() => queries)\n  }\n\n  /**\n   * @return Promise resolving to an array with the refetched queries.\n   */\n  refetchQueries(\n    predicate?: QueryPredicate,\n    options?: RefetchQueriesOptions\n  ): Promise<Query<unknown, unknown>[]> {\n    const promises: Promise<Query<unknown, unknown>>[] = []\n\n    notifyManager.batch(() => {\n      this.getQueries(predicate, options).forEach(query => {\n        let promise = query.fetch().then(() => query)\n\n        if (!options?.throwOnError) {\n          promise = promise.catch(() => query)\n        }\n\n        promises.push(promise)\n      })\n    })\n\n    return Promise.all(promises)\n  }\n\n  resetErrorBoundaries(): void {\n    this.getQueries().forEach(query => {\n      query.state.throwInErrorBoundary = false\n    })\n  }\n\n  buildQuery<TResult, TError = unknown>(\n    queryKey: QueryKey,\n    config?: QueryConfig<TResult, TError>\n  ): Query<TResult, TError> {\n    const resolvedConfig = this.getResolvedQueryConfig(queryKey, config)\n    let query = this.getQueryByHash<TResult, TError>(resolvedConfig.queryHash)\n\n    if (!query) {\n      query = this.createQuery(resolvedConfig)\n    }\n\n    return query\n  }\n\n  createQuery<TResult, TError = unknown>(\n    config: ResolvedQueryConfig<TResult, TError>\n  ): Query<TResult, TError> {\n    const query = new Query(config)\n\n    // A frozen cache does not add new queries to the cache\n    if (!this.config.frozen) {\n      this.queries[query.queryHash] = query\n      this.queriesArray.push(query)\n      this.notifyGlobalListeners(query)\n    }\n\n    return query\n  }\n\n  // Parameter syntax\n  fetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): Promise<TResult>\n\n  // Parameter syntax with query function\n  fetchQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n    queryKey: QueryKey,\n    queryFn: TypedQueryFunction<TResult, TArgs>,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): Promise<TResult>\n\n  fetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TResult>,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): Promise<TResult>\n\n  // Object syntax\n  fetchQuery<TResult = unknown, TError = unknown>(\n    config: FetchQueryObjectConfig<TResult, TError>\n  ): Promise<TResult>\n\n  // Implementation\n  fetchQuery<TResult, TError>(\n    arg1: any,\n    arg2?: any,\n    arg3?: any\n  ): Promise<TResult> {\n    const [queryKey, config] = getQueryArgs<TResult, TError>(arg1, arg2, arg3)\n\n    const resolvedConfig = this.getResolvedQueryConfig(queryKey, {\n      // https://github.com/tannerlinsley/react-query/issues/652\n      retry: false,\n      ...config,\n    })\n\n    let query = this.getQueryByHash<TResult, TError>(resolvedConfig.queryHash)\n\n    if (!query) {\n      query = this.createQuery(resolvedConfig)\n    }\n\n    if (!query.isStaleByTime(config.staleTime)) {\n      return Promise.resolve(query.state.data as TResult)\n    }\n\n    return query.fetch(undefined, resolvedConfig)\n  }\n\n  // Parameter syntax with optional prefetch options\n  prefetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function and optional prefetch options\n  prefetchQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n    queryKey: QueryKey,\n    queryFn: TypedQueryFunction<TResult, TArgs>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  prefetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TResult>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function, config and optional prefetch options\n  prefetchQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n    queryKey: QueryKey,\n    queryFn: TypedQueryFunction<TResult, TArgs>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  prefetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TResult>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Object syntax\n  prefetchQuery<TResult = unknown, TError = unknown>(\n    config: PrefetchQueryObjectConfig<TResult, TError>\n  ): Promise<TResult | undefined>\n\n  // Implementation\n  prefetchQuery<TResult, TError>(\n    arg1: any,\n    arg2?: any,\n    arg3?: any,\n    arg4?: any\n  ): Promise<TResult | undefined> {\n    if (\n      isPlainObject(arg2) &&\n      (arg2.hasOwnProperty('throwOnError') || arg2.hasOwnProperty('force'))\n    ) {\n      arg4 = arg2\n      arg2 = undefined\n      arg3 = undefined\n    }\n\n    const [queryKey, config, options] = getQueryArgs<\n      TResult,\n      TError,\n      PrefetchQueryOptions | undefined\n    >(arg1, arg2, arg3, arg4)\n\n    if (options?.force) {\n      config.staleTime = 0\n    }\n\n    let promise: Promise<TResult | undefined> = this.fetchQuery(\n      queryKey,\n      config\n    )\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  // Parameter syntax\n  watchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): QueryObserver<TResult, TError>\n\n  // Parameter syntax with query function\n  watchQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n    queryKey: QueryKey,\n    queryFn: TypedQueryFunction<TResult, TArgs>,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): QueryObserver<TResult, TError>\n\n  watchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TResult>,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): QueryObserver<TResult, TError>\n\n  // Implementation\n  watchQuery<TResult, TError>(\n    arg1: any,\n    arg2?: any,\n    arg3?: any\n  ): QueryObserver<TResult, TError> {\n    const [queryKey, config] = getQueryArgs<TResult, TError>(arg1, arg2, arg3)\n    const resolvedConfig = this.getResolvedQueryConfig(queryKey, config)\n    return new QueryObserver(resolvedConfig)\n  }\n\n  setQueryData<TResult, TError = unknown>(\n    queryKey: QueryKey,\n    updater: Updater<TResult | undefined, TResult>,\n    config?: QueryConfig<TResult, TError>\n  ) {\n    this.buildQuery(queryKey, config).setData(updater)\n  }\n}\n\nconst defaultQueryCache = new QueryCache({ frozen: isServer })\nexport { defaultQueryCache as queryCache }\nexport const queryCaches = [defaultQueryCache]\n\n/**\n * @deprecated\n */\nexport function makeQueryCache(config?: QueryCacheConfig) {\n  return new QueryCache(config)\n}\n\nexport function onVisibilityOrOnlineChange(type: 'focus' | 'online') {\n  if (isDocumentVisible() && isOnline()) {\n    notifyManager.batch(() => {\n      queryCaches.forEach(queryCache => {\n        queryCache.getQueries().forEach(query => {\n          query.onInteraction(type)\n        })\n      })\n    })\n  }\n}\n","import { createSetHandler, isServer } from './utils'\nimport { onVisibilityOrOnlineChange } from './queryCache'\n\nexport const setFocusHandler = createSetHandler(() =>\n  onVisibilityOrOnlineChange('focus')\n)\n\nsetFocusHandler(handleFocus => {\n  if (isServer || !window?.addEventListener) {\n    return\n  }\n\n  // Listen to visibillitychange and focus\n  window.addEventListener('visibilitychange', handleFocus, false)\n  window.addEventListener('focus', handleFocus, false)\n\n  return () => {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('visibilitychange', handleFocus)\n    window.removeEventListener('focus', handleFocus)\n  }\n})\n","import { createSetHandler, isServer } from './utils'\nimport { onVisibilityOrOnlineChange } from './queryCache'\n\nexport const setOnlineHandler = createSetHandler(() =>\n  onVisibilityOrOnlineChange('online')\n)\n\nsetOnlineHandler(handleOnline => {\n  if (isServer || !window?.addEventListener) {\n    return\n  }\n\n  // Listen to online\n  window.addEventListener('online', handleOnline, false)\n\n  return () => {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('online', handleOnline)\n  }\n})\n","import ReactDOM from 'react-dom'\nexport const unstable_batchedUpdates = ReactDOM.unstable_batchedUpdates\n","import React from 'react'\n\nimport {\n  QueryCache,\n  queryCache as defaultQueryCache,\n  queryCaches,\n} from '../core'\n\nconst queryCacheContext = React.createContext(defaultQueryCache)\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport interface ReactQueryCacheProviderProps {\n  queryCache?: QueryCache\n}\n\nexport const ReactQueryCacheProvider: React.FC<ReactQueryCacheProviderProps> = ({\n  queryCache,\n  children,\n}) => {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || new QueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear({ notify: false })\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { mergeReactQueryConfigs } from '../core/config'\nimport { ReactQueryConfig } from '../core/types'\n\nconst configContext = React.createContext<ReactQueryConfig | undefined>(\n  undefined\n)\n\nexport function useContextConfig() {\n  return React.useContext(configContext)\n}\n\nexport interface ReactQueryConfigProviderProps {\n  config: ReactQueryConfig\n}\n\nexport const ReactQueryConfigProvider: React.FC<ReactQueryConfigProviderProps> = ({\n  config,\n  children,\n}) => {\n  const parentConfig = useContextConfig()\n\n  const mergedConfig = React.useMemo(\n    () =>\n      parentConfig ? mergeReactQueryConfigs(parentConfig, config) : config,\n    [config, parentConfig]\n  )\n\n  return (\n    <configContext.Provider value={mergedConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n","import React from 'react'\n\n// CONTEXT\n\ninterface ReactQueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): ReactQueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst context = React.createContext(createValue())\n\n// HOOK\n\nexport const useErrorResetBoundary = () => React.useContext(context)\n\n// COMPONENT\n\nexport interface ReactQueryErrorResetBoundaryProps {\n  children:\n    | ((value: ReactQueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const ReactQueryErrorResetBoundary: React.FC<ReactQueryErrorResetBoundaryProps> = ({\n  children,\n}) => {\n  const value = React.useMemo(() => createValue(), [])\n  return (\n    <context.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </context.Provider>\n  )\n}\n","import React from 'react'\n\nimport { isServer } from '../core/utils'\n\nexport function useIsMounted(): () => boolean {\n  const mountedRef = React.useRef(false)\n  const isMounted = React.useCallback(() => mountedRef.current, [])\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mountedRef.current = true\n    return () => {\n      mountedRef.current = false\n    }\n  }, [])\n\n  return isMounted\n}\n\nexport function useMountedCallback<T extends Function>(callback: T): T {\n  const isMounted = useIsMounted()\n  return (React.useCallback(\n    (...args: any[]) => {\n      if (isMounted()) {\n        return callback(...args)\n      }\n    },\n    [callback, isMounted]\n  ) as any) as T\n}\n","import React from 'react'\n\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useIsMounted } from './utils'\n\nexport function useIsFetching(): number {\n  const isMounted = useIsMounted()\n  const queryCache = useQueryCache()\n  const [isFetching, setIsFetching] = React.useState(queryCache.isFetching)\n\n  React.useEffect(\n    () =>\n      queryCache.subscribe(() => {\n        if (isMounted()) {\n          setIsFetching(queryCache.isFetching)\n        }\n      }),\n    [queryCache, setIsFetching, isMounted]\n  )\n\n  return isFetching\n}\n","import React from 'react'\n\nimport { useMountedCallback } from './utils'\nimport { getResolvedMutationConfig } from '../core/config'\nimport { Console, uid, getStatusProps } from '../core/utils'\nimport {\n  QueryStatus,\n  MutationResultPair,\n  MutationFunction,\n  MutationConfig,\n  MutateConfig,\n  MutationResult,\n} from '../core/types'\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useContextConfig } from './ReactQueryConfigProvider'\n\n// TYPES\n\ntype Reducer<S, A> = (prevState: S, action: A) => S\n\ninterface State<TResult, TError> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n}\n\nconst enum ActionType {\n  Reset,\n  Loading,\n  Resolve,\n  Reject,\n}\n\ninterface ResetAction {\n  type: ActionType.Reset\n}\n\ninterface LoadingAction {\n  type: ActionType.Loading\n}\n\ninterface ResolveAction<TResult> {\n  type: ActionType.Resolve\n  data: TResult\n}\n\ninterface RejectAction<TError> {\n  type: ActionType.Reject\n  error: TError\n}\n\ntype Action<TResult, TError> =\n  | ResetAction\n  | LoadingAction\n  | ResolveAction<TResult>\n  | RejectAction<TError>\n\n// HOOK\n\nfunction getDefaultState<TResult, TError>(): State<TResult, TError> {\n  return {\n    ...getStatusProps(QueryStatus.Idle),\n    data: undefined,\n    error: null,\n  }\n}\n\nfunction mutationReducer<TResult, TError>(\n  state: State<TResult, TError>,\n  action: Action<TResult, TError>\n): State<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Reset:\n      return getDefaultState()\n    case ActionType.Loading:\n      return {\n        ...getStatusProps(QueryStatus.Loading),\n        data: undefined,\n        error: null,\n      }\n    case ActionType.Resolve:\n      return {\n        ...getStatusProps(QueryStatus.Success),\n        data: action.data,\n        error: null,\n      }\n    case ActionType.Reject:\n      return {\n        ...getStatusProps(QueryStatus.Error),\n        data: undefined,\n        error: action.error,\n      }\n    default:\n      return state\n  }\n}\n\nexport function useMutation<\n  TResult,\n  TError = unknown,\n  TVariables = undefined,\n  TSnapshot = unknown\n>(\n  mutationFn: MutationFunction<TResult, TVariables>,\n  config: MutationConfig<TResult, TError, TVariables, TSnapshot> = {}\n): MutationResultPair<TResult, TError, TVariables, TSnapshot> {\n  const cache = useQueryCache()\n  const contextConfig = useContextConfig()\n\n  // Get resolved config\n  const resolvedConfig = getResolvedMutationConfig(cache, contextConfig, config)\n\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer as Reducer<State<TResult, TError>, Action<TResult, TError>>,\n    null,\n    getDefaultState\n  )\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const latestMutationRef = React.useRef<number>()\n  const latestMutationFnRef = React.useRef(mutationFn)\n  latestMutationFnRef.current = mutationFn\n  const latestConfigRef = React.useRef(resolvedConfig)\n  latestConfigRef.current = resolvedConfig\n\n  const mutate = React.useCallback(\n    async (\n      variables?: TVariables,\n      mutateConfig: MutateConfig<TResult, TError, TVariables, TSnapshot> = {}\n    ): Promise<TResult | undefined> => {\n      const latestConfig = latestConfigRef.current\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      let snapshotValue: TSnapshot | undefined\n\n      try {\n        dispatch({ type: ActionType.Loading })\n        snapshotValue = (await latestConfig.onMutate?.(variables!)) as TSnapshot\n\n        const latestMutationFn = latestMutationFnRef.current\n        const data = await latestMutationFn(variables!)\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Resolve, data })\n        }\n\n        await latestConfig.onSuccess?.(data, variables!)\n        await mutateConfig.onSuccess?.(data, variables!)\n        await latestConfig.onSettled?.(data, null, variables!)\n        await mutateConfig.onSettled?.(data, null, variables!)\n\n        return data\n      } catch (error) {\n        Console.error(error)\n        await latestConfig.onError?.(error, variables!, snapshotValue!)\n        await mutateConfig.onError?.(error, variables!, snapshotValue!)\n        await latestConfig.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue as TSnapshot\n        )\n        await mutateConfig.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue\n        )\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Reject, error })\n        }\n\n        if (mutateConfig.throwOnError || latestConfig.throwOnError) {\n          throw error\n        }\n      }\n    },\n    [dispatch]\n  )\n\n  React.useEffect(() => {\n    const latestConfig = latestConfigRef.current\n    const { suspense, useErrorBoundary } = latestConfig\n    if ((useErrorBoundary || suspense) && state.error) {\n      throw state.error\n    }\n  }, [state.error])\n\n  const reset = React.useCallback(() => {\n    dispatch({ type: ActionType.Reset })\n  }, [dispatch])\n\n  const result: MutationResult<TResult, TError> = {\n    ...state,\n    reset,\n  }\n\n  return [mutate, result]\n}\n","import React from 'react'\n\nimport { useIsMounted } from './utils'\nimport { getResolvedQueryConfig } from '../core/config'\nimport { QueryObserver } from '../core/queryObserver'\nimport { QueryResultBase, QueryKey, QueryConfig } from '../core/types'\nimport { useErrorResetBoundary } from './ReactQueryErrorResetBoundary'\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useContextConfig } from './ReactQueryConfigProvider'\n\nexport function useBaseQuery<TResult, TError>(\n  queryKey: QueryKey,\n  config?: QueryConfig<TResult, TError>\n): QueryResultBase<TResult, TError> {\n  const [, rerender] = React.useReducer(c => c + 1, 0)\n  const isMounted = useIsMounted()\n  const cache = useQueryCache()\n  const contextConfig = useContextConfig()\n  const errorResetBoundary = useErrorResetBoundary()\n\n  // Get resolved config\n  const resolvedConfig = getResolvedQueryConfig(\n    cache,\n    queryKey,\n    contextConfig,\n    config\n  )\n\n  // Create query observer\n  const observerRef = React.useRef<QueryObserver<TResult, TError>>()\n  const firstRender = !observerRef.current\n  const observer = observerRef.current || new QueryObserver(resolvedConfig)\n  observerRef.current = observer\n\n  // Subscribe to the observer\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n    return observer.subscribe(() => {\n      if (isMounted()) {\n        rerender()\n      }\n    })\n  }, [isMounted, observer, rerender, errorResetBoundary])\n\n  // Update config\n  if (!firstRender) {\n    observer.updateConfig(resolvedConfig)\n  }\n\n  const result = observer.getCurrentResult()\n\n  // Handle suspense\n  if (resolvedConfig.suspense || resolvedConfig.useErrorBoundary) {\n    const query = observer.getCurrentQuery()\n\n    if (\n      result.isError &&\n      !errorResetBoundary.isReset() &&\n      query.state.throwInErrorBoundary\n    ) {\n      throw result.error\n    }\n\n    if (\n      resolvedConfig.enabled &&\n      resolvedConfig.suspense &&\n      !result.isSuccess\n    ) {\n      errorResetBoundary.clearReset()\n      const unsubscribe = observer.subscribe()\n      throw observer.fetch().finally(unsubscribe)\n    }\n  }\n\n  return result\n}\n","import {\n  QueryConfig,\n  QueryFunction,\n  QueryKey,\n  QueryResult,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\nimport { useBaseQuery } from './useBaseQuery'\n\n// TYPES\n\nexport interface UseQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: QueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Object syntax\nexport function useQuery<TResult = unknown, TError = unknown>(\n  config: UseQueryObjectConfig<TResult, TError>\n): QueryResult<TResult, TError>\n  \n// Parameter syntax with optional config\nexport function useQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n  queryKey: QueryKey,\n  queryFn: TypedQueryFunction<TResult, TArgs>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\nexport function useQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TResult>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n\n// Implementation\nexport function useQuery<TResult, TError>(\n  arg1: any,\n  arg2?: any,\n  arg3?: any\n): QueryResult<TResult, TError> {\n  const [queryKey, config] = getQueryArgs<TResult, TError>(arg1, arg2, arg3)\n  return useBaseQuery(queryKey, config)\n}\n","import {\n  PaginatedQueryConfig,\n  PaginatedQueryResult,\n  QueryFunction,\n  QueryKey,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\nimport { useBaseQuery } from './useBaseQuery'\n\n// A paginated query is more like a \"lag\" query, which means\n// as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\n\n// TYPES\n\nexport interface UsePaginatedQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: PaginatedQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Object syntax\nexport function usePaginatedQuery<TResult = unknown, TError = unknown>(\n  config: UsePaginatedQueryObjectConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Parameter syntax with optional config\nexport function usePaginatedQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TArgs extends TypedQueryFunctionArgs\n>(\n  queryKey: QueryKey,\n  queryFn: TypedQueryFunction<TResult, TArgs>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\nexport function usePaginatedQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TResult>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Implementation\nexport function usePaginatedQuery<TResult, TError>(\n  arg1: any,\n  arg2?: any,\n  arg3?: any\n): PaginatedQueryResult<TResult, TError> {\n  const [queryKey, config] = getQueryArgs<TResult, TError>(arg1, arg2, arg3)\n  const result = useBaseQuery(queryKey, {\n    keepPreviousData: true,\n    ...config,\n  })\n  return {\n    ...result,\n    resolvedData: result.data,\n    latestData: result.isPreviousData ? undefined : result.data,\n  }\n}\n","import {\n  InfiniteQueryConfig,\n  InfiniteQueryResult,\n  QueryFunction,\n  QueryKey,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\nimport { useBaseQuery } from './useBaseQuery'\n\n// TYPES\n\nexport interface UseInfiniteQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: InfiniteQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Object syntax\nexport function useInfiniteQuery<TResult = unknown, TError = unknown>(\n  config: UseInfiniteQueryObjectConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n  \n// Parameter syntax with optional config\nexport function useInfiniteQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TArgs extends TypedQueryFunctionArgs\n>(\n  queryKey: QueryKey,\n  queryFn: TypedQueryFunction<TResult, TArgs>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\nexport function useInfiniteQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TResult>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Implementation\nexport function useInfiniteQuery<TResult, TError>(\n  arg1: any,\n  arg2?: any,\n  arg3?: any\n): InfiniteQueryResult<TResult, TError> {\n  const [queryKey, config] = getQueryArgs<TResult[], TError>(arg1, arg2, arg3)\n  return useBaseQuery(queryKey, { ...config, infinite: true })\n}\n","import { setBatchedUpdates } from './core/index'\nimport { unstable_batchedUpdates } from './react/reactBatchedUpdates'\nsetBatchedUpdates(unstable_batchedUpdates)\n\nexport * from './core/index'\nexport * from './react/index'\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","QueryStatus","CancelledError","silent","_uid","uid","isServer","window","noop","undefined","Console","console","error","warn","log","setConsole","c","functionalUpdate","updater","input","stableStringifyReplacer","_key","value","Error","isPlainObject","keys","sort","reduce","result","stableStringify","JSON","stringify","deepIncludes","a","b","some","isValidTimeout","Infinity","isDocumentVisible","document","includes","visibilityState","isOnline","navigator","onLine","getQueryArgs","arg1","arg2","arg3","arg4","queryKey","queryFn","config","options","replaceEqualDeep","array","Array","isArray","aSize","bItems","bSize","copy","equalItems","o","hasObjectPrototype","ctor","constructor","prot","toString","isCancelable","cancel","isError","isCancelledError","sleep","timeout","Promise","resolve","setTimeout","getStatusProps","status","isLoading","Loading","isSuccess","Success","isIdle","Idle","createSetHandler","fn","removePreviousHandler","callback","scheduleMicrotask","then","catch","batchedUpdates","setBatchedUpdates","getBatchedUpdates","defaultQueryKeySerializerFn","arrayQueryKey","queryHash","parse","DEFAULT_CONFIG","queries","cacheTime","enabled","notifyOnStatusChange","reject","queryKeySerializerFn","refetchOnMount","refetchOnReconnect","refetchOnWindowFocus","retry","retryDelay","attemptIndex","Math","min","staleTime","structuralSharing","getDefaultReactQueryConfig","mutations","mergeReactQueryConfigs","shared","getResolvedQueryConfig","queryCache","contextConfig","queryCacheConfig","getDefaultConfig","resolvedConfig","isResolvedQueryConfig","Boolean","getResolvedMutationConfig","NotifyManager","queue","transactions","batch","flush","schedule","notify","push","forEach","notifyManager","QueryObserver","isStale","initialUpdateCount","remove","bind","refetch","fetchMore","unsubscribe","updateQuery","subscribe","listener","currentQuery","subscribeObserver","forceFetchOnMount","fetch","optionalFetch","updateTimers","clearTimers","unsubscribeObserver","updateConfig","prevConfig","prevQuery","updateStaleTimeout","refetchInterval","updateRefetchInterval","getCurrentQuery","getCurrentResult","currentResult","clear","fetchMoreVariable","data","suspense","isFetched","observers","clearStaleTimeout","timeElapsed","Date","now","updatedAt","timeUntilStale","max","staleTimeoutId","updateResult","globalListeners","clearRefetchInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearTimeout","clearInterval","state","isPreviousData","isPlaceholderData","keepPreviousData","isInitialData","previousQueryResult","placeholderData","canFetchMore","failureCount","updateCount","isFetchedAfterMount","isFetching","isFetchingMore","query","getQueryByHash","createQuery","initialStale","isStaleByTime","onQueryUpdate","action","type","prevResult","notifyOptions","onSuccess","onError","onSettled","notifyGlobalListeners","_empty","direct","body","recover","e","f","args","Query","getDefaultState","scheduleGc","dispatch","queryReducer","observer","clearGcTimeout","gcTimeout","promise","cancelFetch","continue","continueFetch","clearTimersObservers","setData","prevData","isDataEqual","hasMorePages","ActionType","removeQuery","destroy","isActive","isInvalidated","onInteraction","staleObserver","find","filter","x","isTransportCancelable","invalidate","Invalidate","throwOnError","previous","queryFnParamsFilter","params","infinite","startInfiniteFetch","startFetch","_options","fetchData","Fetch","tryFetchData","prevPages","fetchPage","pages","prepend","cursor","lastPage","getLastPage","getFetchMore","page","outerResolve","outerReject","resolved","continueLoop","cancelTransport","done","run","promiseOrValue","shouldRetry","Failed","continueResolve","initialData","throwInErrorBoundary","QueryCache","queriesArray","getQueries","acc","q","defaultConfig","removeQueries","predicate","anyKey","predicateFn","exact","active","stale","getQuery","getQueryData","cancelQueries","invalidateQueries","refetchActive","refetchInactive","refetchOptions","refetchQueries","promises","all","resetErrorBoundaries","buildQuery","frozen","fetchQuery","prefetchQuery","force","watchQuery","setQueryData","defaultQueryCache","queryCaches","makeQueryCache","onVisibilityOrOnlineChange","setFocusHandler","handleFocus","addEventListener","removeEventListener","setOnlineHandler","handleOnline","unstable_batchedUpdates","ReactDOM","queryCacheContext","React","createContext","useQueryCache","useContext","ReactQueryCacheProvider","children","resolvedQueryCache","useMemo","useEffect","indexOf","splice","configContext","useContextConfig","ReactQueryConfigProvider","parentConfig","mergedConfig","createValue","isReset","clearReset","reset","context","useErrorResetBoundary","ReactQueryErrorResetBoundary","useIsMounted","mountedRef","useRef","isMounted","useCallback","current","useMountedCallback","useIsFetching","useState","setIsFetching","_await","mutationReducer","Reset","Resolve","Reject","useMutation","mutationFn","cache","useReducer","unsafeDispatch","latestMutationRef","latestMutationFnRef","latestConfigRef","mutate","variables","mutateConfig","latestConfig","mutationId","isLatest","snapshotValue","onMutate","latestMutationFn","useErrorBoundary","useBaseQuery","rerender","errorResetBoundary","observerRef","firstRender","finally","useQuery","usePaginatedQuery","resolvedData","latestData","useInfiniteQuery"],"mappings":"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"}
{"version":3,"file":"react-query.min.mjs","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../src/core/types.ts","../src/core/utils.ts","../src/core/config.ts","../src/core/notifyManager.ts","../src/core/queryObserver.ts","../src/core/query.ts","../src/core/queryCache.ts","../src/core/setFocusHandler.ts","../src/core/setOnlineHandler.ts","../src/react/reactBatchedUpdates.ts","../src/react/ReactQueryCacheProvider.tsx","../src/react/ReactQueryConfigProvider.tsx","../src/react/ReactQueryErrorResetBoundary.tsx","../src/react/utils.ts","../src/react/useIsFetching.ts","../src/react/useMutation.ts","../src/react/useBaseQuery.ts","../src/react/useQuery.ts","../src/react/usePaginatedQuery.ts","../src/react/useInfiniteQuery.ts","../src/index.ts"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import type { FetchMoreOptions, RefetchOptions } from './query'\nimport type { QueryCache } from './queryCache'\n\nexport type QueryKey =\n  | boolean\n  | null\n  | number\n  | object\n  | string\n  | undefined\n  | { [key: number]: QueryKey }\n  | { [key: string]: QueryKey }\n  | readonly QueryKey[]\n\nexport type ArrayQueryKey = QueryKey[]\n\nexport type QueryFunction<TResult> = (\n  ...args: any[]\n) => TResult | Promise<TResult>\n\nexport type TypedQueryFunction<\n  TResult,\n  TArgs extends TypedQueryFunctionArgs = TypedQueryFunctionArgs\n> = (...args: TArgs) => TResult | Promise<TResult>\n\nexport type TypedQueryFunctionArgs = readonly [unknown, ...unknown[]]\n\nexport type InitialDataFunction<TResult> = () => TResult | undefined\nexport type PlaceholderDataFunction<TResult> = () => TResult | undefined\n\nexport type InitialStaleFunction = () => boolean\n\nexport type QueryKeySerializerFunction = (\n  queryKey: QueryKey\n) => [string, QueryKey[]]\n\nexport interface BaseQueryConfig<TResult, TError = unknown, TData = TResult> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: boolean | number | ((failureCount: number, error: TError) => boolean)\n  retryDelay?: number | ((retryAttempt: number) => number)\n  cacheTime?: number\n  isDataEqual?: (oldData: unknown, newData: unknown) => boolean\n  queryFn?: QueryFunction<TData>\n  queryKey?: QueryKey\n  queryKeySerializerFn?: QueryKeySerializerFunction\n  queryFnParamsFilter?: (args: ArrayQueryKey) => ArrayQueryKey\n  initialData?: TResult | InitialDataFunction<TResult>\n  placeholderData?: TResult | InitialDataFunction<TResult>\n  infinite?: true\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Defaults to `true`.\n   */\n  structuralSharing?: boolean\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `canFetchMore`.\n   */\n  getFetchMore?: (lastPage: TData, allPages: TData[]) => unknown\n}\n\nexport interface QueryObserverConfig<\n  TResult,\n  TError = unknown,\n  TData = TResult\n> extends BaseQueryConfig<TResult, TError, TData> {\n  /**\n   * Set this to `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Defaults to `true`.\n   */\n  enabled?: boolean | unknown\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be stale.\n   */\n  staleTime?: number\n  /**\n   * If set, this will mark any `initialData` provided as stale and will likely cause it to be refetched on mount.\n   * If a function is passed, it will be called only when appropriate to resolve the `initialStale` value.\n   * This can be useful if your `initialStale` value is costly to calculate.\n   */\n  initialStale?: boolean | InitialStaleFunction\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * Defaults to `false`.\n   */\n  refetchInterval?: number | false\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?: boolean | 'always'\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * Defaults to `true`.\n   */\n  refetchOnReconnect?: boolean | 'always'\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetches.\n   * If set to `'always'`, the query will always refetch on mount.\n   * Defaults to `true`.\n   */\n  refetchOnMount?: boolean | 'always'\n  /**\n   * Set this to `true` to always fetch when the component mounts (regardless of staleness).\n   * Defaults to `false`.\n   */\n  forceFetchOnMount?: boolean\n  /**\n   * Whether a change to the query status should re-render a component.\n   * If set to `false`, the component will only re-render when the actual `data` or `error` changes.\n   * Defaults to `true`.\n   */\n  notifyOnStatusChange?: boolean\n  /**\n   * This callback will fire any time the query successfully fetches new data.\n   */\n  onSuccess?: (data: TResult) => void\n  /**\n   * This callback will fire if the query encounters an error and will be passed the error.\n   */\n  onError?: (err: TError) => void\n  /**\n   * This callback will fire any time the query is either successfully fetched or errors and be passed either the data or error.\n   */\n  onSettled?: (data: TResult | undefined, error: TError | null) => void\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * Defaults to `false`.\n   */\n  useErrorBoundary?: boolean\n  /**\n   * If set to `true`, the query will suspend when `status === 'loading'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * Set this to `true` to keep the previous `data` when fetching based on a new query key.\n   * Defaults to `false`.\n   */\n  keepPreviousData?: boolean\n}\n\nexport interface QueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface PaginatedQueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface InfiniteQueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult[], TError, TResult> {}\n\nexport interface ResolvedQueryConfig<TResult, TError = unknown>\n  extends QueryConfig<TResult, TError> {\n  cacheTime: number\n  queryCache: QueryCache\n  queryFn: QueryFunction<TResult>\n  queryHash: string\n  queryKey: ArrayQueryKey\n  queryKeySerializerFn: QueryKeySerializerFunction\n  staleTime: number\n}\n\nexport type IsFetchingMoreValue = 'previous' | 'next' | false\n\nexport enum QueryStatus {\n  Idle = 'idle',\n  Loading = 'loading',\n  Error = 'error',\n  Success = 'success',\n}\n\nexport interface QueryResultBase<TResult, TError = unknown> {\n  canFetchMore: boolean | undefined\n  clear: () => void\n  data: TResult | undefined\n  error: TError | null\n  failureCount: number\n  fetchMore: (\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ) => Promise<TResult | undefined>\n  isError: boolean\n  isFetched: boolean\n  isFetchedAfterMount: boolean\n  isFetching: boolean\n  isFetchingMore?: IsFetchingMoreValue\n  isIdle: boolean\n  isInitialData: boolean\n  isLoading: boolean\n  isPreviousData: boolean\n  isPlaceholderData: boolean\n  isStale: boolean\n  isSuccess: boolean\n  refetch: (options?: RefetchOptions) => Promise<TResult | undefined>\n  remove: () => void\n  status: QueryStatus\n  updatedAt: number\n}\n\nexport interface QueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {}\n\nexport interface PaginatedQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {\n  resolvedData: TResult | undefined\n  latestData: TResult | undefined\n}\n\nexport interface InfiniteQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult[], TError> {}\n\nexport interface MutateConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> {\n  onSuccess?: (data: TResult, variables: TVariables) => Promise<unknown> | void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    snapshotValue: TSnapshot\n  ) => Promise<unknown> | void\n  onSettled?: (\n    data: undefined | TResult,\n    error: TError | null,\n    variables: TVariables,\n    snapshotValue?: TSnapshot\n  ) => Promise<unknown> | void\n  throwOnError?: boolean\n}\n\nexport interface MutationConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutateConfig<TResult, TError, TVariables, TSnapshot> {\n  onMutate?: (variables: TVariables) => Promise<TSnapshot> | TSnapshot\n  useErrorBoundary?: boolean\n  suspense?: boolean\n  /**\n   * By default the query cache from the context is used, but a different cache can be specified.\n   */\n  queryCache?: QueryCache\n}\n\nexport type MutationFunction<TResult, TVariables = unknown> = (\n  variables: TVariables\n) => Promise<TResult>\n\nexport type MutateFunction<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> = (\n  variables?: TVariables,\n  config?: MutateConfig<TResult, TError, TVariables, TSnapshot>\n) => Promise<TResult | undefined>\n\nexport type MutationResultPair<TResult, TError, TVariables, TSnapshot> = [\n  MutateFunction<TResult, TError, TVariables, TSnapshot>,\n  MutationResult<TResult, TError>\n]\n\nexport interface MutationResult<TResult, TError = unknown> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n  reset: () => void\n}\n\nexport interface ReactQueryConfig<TResult = unknown, TError = unknown> {\n  queries?: ReactQueryQueriesConfig<TResult, TError>\n  shared?: ReactQuerySharedConfig\n  mutations?: ReactQueryMutationsConfig<TResult, TError>\n}\n\nexport interface ReactQuerySharedConfig {\n  suspense?: boolean\n}\n\nexport interface ReactQueryQueriesConfig<TResult, TError>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface ReactQueryMutationsConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutationConfig<TResult, TError, TVariables, TSnapshot> {}\n","import { QueryConfig, QueryStatus, QueryKey, QueryFunction } from './types'\n\n// TYPES\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\ntype ConsoleFunction = (...args: any[]) => void\n\nexport interface ConsoleObject {\n  log: ConsoleFunction\n  warn: ConsoleFunction\n  error: ConsoleFunction\n}\n\ninterface Cancelable {\n  cancel(): void\n}\n\nexport class CancelledError {\n  silent?: boolean\n  constructor(silent?: boolean) {\n    this.silent = silent\n  }\n}\n\n// UTILS\n\nlet _uid = 0\nexport function uid(): number {\n  return _uid++\n}\n\nexport const isServer = typeof window === 'undefined'\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport let Console: ConsoleObject = console || {\n  error: noop,\n  warn: noop,\n  log: noop,\n}\n\nexport function setConsole(c: ConsoleObject) {\n  Console = c\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nfunction stableStringifyReplacer(_key: string, value: any): unknown {\n  if (typeof value === 'function') {\n    throw new Error()\n  }\n\n  if (isPlainObject(value)) {\n    return Object.keys(value)\n      .sort()\n      .reduce((result, key) => {\n        result[key] = value[key]\n        return result\n      }, {} as any)\n  }\n\n  return value\n}\n\nexport function stableStringify(value: any): string {\n  return JSON.stringify(value, stableStringifyReplacer)\n}\n\nexport function deepIncludes(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isValidTimeout(value: any): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function isDocumentVisible(): boolean {\n  // document global can be unavailable in react native\n  if (typeof document === 'undefined') {\n    return true\n  }\n  return [undefined, 'visible', 'prerender'].includes(document.visibilityState)\n}\n\nexport function isOnline(): boolean {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs<TResult, TError, TOptions = undefined>(\n  arg1: any,\n  arg2?: any,\n  arg3?: any,\n  arg4?: any\n): [QueryKey, QueryConfig<TResult, TError>, TOptions] {\n  let queryKey: QueryKey\n  let queryFn: QueryFunction<TResult> | undefined\n  let config: QueryConfig<TResult, TError> | undefined\n  let options: TOptions\n\n  if (isPlainObject(arg1)) {\n    queryKey = arg1.queryKey\n    queryFn = arg1.queryFn\n    config = arg1.config\n    options = arg2\n  } else if (isPlainObject(arg2)) {\n    queryKey = arg1\n    config = arg2\n    options = arg3\n  } else {\n    queryKey = arg1\n    queryFn = arg2\n    config = arg3\n    options = arg4\n  }\n\n  config = config || {}\n\n  if (queryFn) {\n    config = { ...config, queryFn }\n  }\n\n  return [queryKey, config, options]\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = Array.isArray(a) && Array.isArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isCancelable(value: any): value is Cancelable {\n  return typeof value?.cancel === 'function'\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function getStatusProps<T extends QueryStatus>(status: T) {\n  return {\n    status,\n    isLoading: status === QueryStatus.Loading,\n    isSuccess: status === QueryStatus.Success,\n    isError: status === QueryStatus.Error,\n    isIdle: status === QueryStatus.Idle,\n  }\n}\n\nexport function createSetHandler(fn: () => void) {\n  let removePreviousHandler: (() => void) | void\n  return (callback: (handler: () => void) => void) => {\n    // Unsub the old handler\n    if (removePreviousHandler) {\n      removePreviousHandler()\n    }\n    // Sub the new handler\n    removePreviousHandler = callback(fn)\n  }\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void): void {\n  Promise.resolve()\n    .then(callback)\n    .catch(error =>\n      setTimeout(() => {\n        throw error\n      })\n    )\n}\n\ntype BatchUpdateFunction = (callback: () => void) => void\n\n// Default to a dummy \"batch\" implementation that just runs the callback\nlet batchedUpdates: BatchUpdateFunction = (callback: () => void) => {\n  callback()\n}\n\n// Allow injecting another batching function later\nexport function setBatchedUpdates(fn: BatchUpdateFunction) {\n  batchedUpdates = fn\n}\n\n// Supply a getter just to skip dealing with ESM bindings\nexport function getBatchedUpdates(): BatchUpdateFunction {\n  return batchedUpdates\n}\n","import { stableStringify } from './utils'\nimport type {\n  ArrayQueryKey,\n  MutationConfig,\n  QueryConfig,\n  QueryKey,\n  QueryKeySerializerFunction,\n  ReactQueryConfig,\n  ResolvedQueryConfig,\n} from './types'\nimport type { QueryCache } from './queryCache'\n\n// TYPES\n\nexport interface ReactQueryConfigRef {\n  current: ReactQueryConfig\n}\n\n// CONFIG\n\nexport const defaultQueryKeySerializerFn: QueryKeySerializerFunction = (\n  queryKey: QueryKey\n): [string, ArrayQueryKey] => {\n  try {\n    let arrayQueryKey: ArrayQueryKey = Array.isArray(queryKey)\n      ? queryKey\n      : [queryKey]\n    const queryHash = stableStringify(arrayQueryKey)\n    arrayQueryKey = JSON.parse(queryHash)\n    return [queryHash, arrayQueryKey]\n  } catch {\n    throw new Error('A valid query key is required!')\n  }\n}\n\n/**\n * Config merging strategy\n *\n * When using hooks the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the hook query cache.\n * 3. Combined defaults from any config providers in the tree.\n * 4. Query/mutation config provided to the hook.\n *\n * When using a query cache directly the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the query cache.\n * 3. Query/mutation config provided to the query cache method.\n */\nexport const DEFAULT_CONFIG: ReactQueryConfig = {\n  queries: {\n    cacheTime: 5 * 60 * 1000,\n    enabled: true,\n    notifyOnStatusChange: true,\n    queryFn: () => Promise.reject(),\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    refetchOnMount: true,\n    refetchOnReconnect: true,\n    refetchOnWindowFocus: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    structuralSharing: true,\n  },\n}\n\nexport function getDefaultReactQueryConfig() {\n  return {\n    queries: { ...DEFAULT_CONFIG.queries },\n    mutations: { ...DEFAULT_CONFIG.mutations },\n  }\n}\n\nexport function mergeReactQueryConfigs(\n  a: ReactQueryConfig,\n  b: ReactQueryConfig\n): ReactQueryConfig {\n  return {\n    shared: {\n      ...a.shared,\n      ...b.shared,\n    },\n    queries: {\n      ...a.queries,\n      ...b.queries,\n    },\n    mutations: {\n      ...a.mutations,\n      ...b.mutations,\n    },\n  }\n}\n\nexport function getResolvedQueryConfig<TResult, TError>(\n  queryCache: QueryCache,\n  queryKey: QueryKey,\n  contextConfig?: ReactQueryConfig,\n  config?: QueryConfig<TResult, TError>\n): ResolvedQueryConfig<TResult, TError> {\n  const queryCacheConfig = queryCache.getDefaultConfig()\n\n  const resolvedConfig = {\n    ...DEFAULT_CONFIG.queries,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.queries,\n    ...contextConfig?.shared,\n    ...contextConfig?.queries,\n    ...config,\n  } as ResolvedQueryConfig<TResult, TError>\n\n  const result = resolvedConfig.queryKeySerializerFn(queryKey)\n\n  resolvedConfig.queryCache = queryCache\n  resolvedConfig.queryHash = result[0]\n  resolvedConfig.queryKey = result[1]\n\n  return resolvedConfig\n}\n\nexport function isResolvedQueryConfig<TResult, TError>(\n  config: any\n): config is ResolvedQueryConfig<TResult, TError> {\n  return Boolean(config.queryHash)\n}\n\nexport function getResolvedMutationConfig<\n  TResult,\n  TError,\n  TVariables,\n  TSnapshot\n>(\n  queryCache: QueryCache,\n  contextConfig?: ReactQueryConfig,\n  config?: MutationConfig<TResult, TError, TVariables, TSnapshot>\n): MutationConfig<TResult, TError, TVariables, TSnapshot> {\n  const queryCacheConfig = queryCache.getDefaultConfig()\n  return {\n    ...DEFAULT_CONFIG.mutations,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.mutations,\n    ...contextConfig?.shared,\n    ...contextConfig?.mutations,\n    ...config,\n  } as MutationConfig<TResult, TError, TVariables, TSnapshot>\n}\n","import { getBatchedUpdates, scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\n// CLASS\n\nexport class NotifyManager {\n  private queue: NotifyCallback[]\n  private transactions: number\n\n  constructor() {\n    this.queue = []\n    this.transactions = 0\n  }\n\n  batch<T>(callback: () => T): T {\n    this.transactions++\n    const result = callback()\n    this.transactions--\n    if (!this.transactions) {\n      this.flush()\n    }\n    return result\n  }\n\n  schedule(notify: NotifyCallback): void {\n    if (this.transactions) {\n      this.queue.push(notify)\n    } else {\n      scheduleMicrotask(() => {\n        notify()\n      })\n    }\n  }\n\n  flush(): void {\n    const queue = this.queue\n    this.queue = []\n    if (queue.length) {\n      scheduleMicrotask(() => {\n        const batchedUpdates = getBatchedUpdates()\n        batchedUpdates(() => {\n          queue.forEach(notify => {\n            notify()\n          })\n        })\n      })\n    }\n  }\n}\n\n// SINGLETON\n\nexport const notifyManager = new NotifyManager()\n","import {\n  getStatusProps,\n  isDocumentVisible,\n  isServer,\n  isValidTimeout,\n  noop,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  QueryConfig,\n  QueryResult,\n  ResolvedQueryConfig,\n  PlaceholderDataFunction,\n} from './types'\nimport { QueryStatus } from './types'\nimport type { Query, Action, FetchMoreOptions, RefetchOptions } from './query'\nimport { DEFAULT_CONFIG, isResolvedQueryConfig } from './config'\n\nexport type UpdateListener<TResult, TError> = (\n  result: QueryResult<TResult, TError>\n) => void\n\ninterface NotifyOptions {\n  globalListeners?: boolean\n  listener?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport class QueryObserver<TResult, TError> {\n  config: ResolvedQueryConfig<TResult, TError>\n\n  private currentQuery!: Query<TResult, TError>\n  private currentResult!: QueryResult<TResult, TError>\n  private previousQueryResult?: QueryResult<TResult, TError>\n  private listener?: UpdateListener<TResult, TError>\n  private isStale: boolean\n  private initialUpdateCount: number\n  private staleTimeoutId?: number\n  private refetchIntervalId?: number\n\n  constructor(config: ResolvedQueryConfig<TResult, TError>) {\n    this.config = config\n    this.isStale = true\n    this.initialUpdateCount = 0\n\n    // Bind exposed methods\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n    this.fetchMore = this.fetchMore.bind(this)\n    this.unsubscribe = this.unsubscribe.bind(this)\n\n    // Subscribe to the query\n    this.updateQuery()\n  }\n\n  subscribe(listener?: UpdateListener<TResult, TError>): () => void {\n    this.listener = listener || noop\n    this.currentQuery.subscribeObserver(this)\n\n    if (\n      this.config.enabled &&\n      (this.config.forceFetchOnMount || this.config.refetchOnMount === 'always')\n    ) {\n      this.fetch()\n    } else {\n      this.optionalFetch()\n    }\n\n    this.updateTimers()\n\n    return this.unsubscribe\n  }\n\n  unsubscribe(): void {\n    this.listener = undefined\n    this.clearTimers()\n    this.currentQuery.unsubscribeObserver(this)\n  }\n\n  updateConfig(\n    config: QueryConfig<TResult, TError> | ResolvedQueryConfig<TResult, TError>\n  ): void {\n    const prevConfig = this.config\n    const prevQuery = this.currentQuery\n\n    this.config = isResolvedQueryConfig(config)\n      ? config\n      : this.config.queryCache.getResolvedQueryConfig(\n          this.config.queryKey,\n          config\n        )\n\n    this.updateQuery()\n\n    // Take no further actions if there is no subscriber\n    if (!this.listener) {\n      return\n    }\n\n    // If we subscribed to a new query, optionally fetch and update refetch\n    if (this.currentQuery !== prevQuery) {\n      this.optionalFetch()\n      this.updateTimers()\n      return\n    }\n\n    // Optionally fetch if the query became enabled\n    if (config.enabled && !prevConfig.enabled) {\n      this.optionalFetch()\n    }\n\n    // Update stale interval if needed\n    if (\n      config.enabled !== prevConfig.enabled ||\n      config.staleTime !== prevConfig.staleTime\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    // Update refetch interval if needed\n    if (\n      config.enabled !== prevConfig.enabled ||\n      config.refetchInterval !== prevConfig.refetchInterval\n    ) {\n      this.updateRefetchInterval()\n    }\n  }\n\n  getCurrentQuery(): Query<TResult, TError> {\n    return this.currentQuery\n  }\n\n  getCurrentResult(): QueryResult<TResult, TError> {\n    return this.currentResult\n  }\n\n  /**\n   * @deprecated\n   */\n  clear(): void {\n    this.remove()\n  }\n\n  remove(): void {\n    this.currentQuery.remove()\n  }\n\n  refetch(options?: RefetchOptions): Promise<TResult | undefined> {\n    return this.currentQuery.refetch(options, this.config)\n  }\n\n  fetchMore(\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ): Promise<TResult | undefined> {\n    return this.currentQuery\n      .fetchMore(fetchMoreVariable, options, this.config)\n      .catch(noop)\n  }\n\n  fetch(): Promise<TResult | undefined> {\n    // Never try to fetch if no query function has been set\n    if (this.config.queryFn === DEFAULT_CONFIG.queries?.queryFn) {\n      return Promise.resolve(this.currentResult.data)\n    }\n\n    return this.currentQuery.fetch(undefined, this.config).catch(noop)\n  }\n\n  private optionalFetch(): void {\n    if (\n      this.config.enabled && // Only fetch if enabled\n      this.isStale && // Only fetch if stale\n      !(this.config.suspense && this.currentResult.isFetched) && // Don't refetch if in suspense mode and the data is already fetched\n      (this.config.refetchOnMount || this.currentQuery.observers.length === 1)\n    ) {\n      this.fetch()\n    }\n  }\n\n  private updateStaleTimeout(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearStaleTimeout()\n\n    if (this.isStale || !isValidTimeout(this.config.staleTime)) {\n      return\n    }\n\n    const timeElapsed = Date.now() - this.currentResult.updatedAt\n    const timeUntilStale = this.config.staleTime - timeElapsed + 1\n    const timeout = Math.max(timeUntilStale, 0)\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.isStale) {\n        this.isStale = true\n        this.updateResult()\n        this.notify({ listener: true, globalListeners: true })\n      }\n    }, timeout)\n  }\n\n  private updateRefetchInterval(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearRefetchInterval()\n\n    if (!this.config.enabled || !isValidTimeout(this.config.refetchInterval)) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.config.refetchIntervalInBackground || isDocumentVisible()) {\n        this.fetch()\n      }\n    }, this.config.refetchInterval)\n  }\n\n  updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval()\n  }\n\n  clearTimers(): void {\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n  }\n\n  private clearStaleTimeout(): void {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId)\n      this.staleTimeoutId = undefined\n    }\n  }\n\n  private clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  private updateResult(): void {\n    const { state } = this.currentQuery\n    let { data, status, updatedAt } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n\n    // Keep previous data if needed\n    if (\n      this.config.keepPreviousData &&\n      state.isInitialData &&\n      this.previousQueryResult?.isSuccess\n    ) {\n      data = this.previousQueryResult.data\n      updatedAt = this.previousQueryResult.updatedAt\n      status = this.previousQueryResult.status\n      isPreviousData = true\n    }\n\n    if (status === 'loading' && this.config.placeholderData) {\n      const placeholderData =\n        typeof this.config.placeholderData === 'function'\n          ? (this.config.placeholderData as PlaceholderDataFunction<TResult>)()\n          : this.config.placeholderData\n\n      if (typeof placeholderData !== 'undefined') {\n        status = QueryStatus.Success\n        data = placeholderData\n        isPlaceholderData = true\n      }\n    }\n\n    this.currentResult = {\n      ...getStatusProps(status),\n      canFetchMore: state.canFetchMore,\n      clear: this.remove,\n      data,\n      error: state.error,\n      failureCount: state.failureCount,\n      fetchMore: this.fetchMore,\n      isFetched: state.updateCount > 0,\n      isFetchedAfterMount: state.updateCount > this.initialUpdateCount,\n      isFetching: state.isFetching,\n      isFetchingMore: state.isFetchingMore,\n      isInitialData: state.isInitialData,\n      isPreviousData,\n      isPlaceholderData,\n      isStale: this.isStale,\n      refetch: this.refetch,\n      remove: this.remove,\n      updatedAt,\n    }\n  }\n\n  private updateQuery(): void {\n    const config = this.config\n    const prevQuery = this.currentQuery\n\n    let query = config.queryCache.getQueryByHash<TResult, TError>(\n      config.queryHash\n    )\n\n    if (!query) {\n      query = config.queryCache.createQuery(config)\n    }\n\n    if (query === prevQuery) {\n      return\n    }\n\n    this.previousQueryResult = this.currentResult\n    this.currentQuery = query\n    this.initialUpdateCount = query.state.updateCount\n\n    // Update stale state on query switch\n    if (query.state.isInitialData) {\n      if (config.keepPreviousData && prevQuery) {\n        this.isStale = true\n      } else if (typeof config.initialStale === 'function') {\n        this.isStale = config.initialStale()\n      } else if (typeof config.initialStale === 'boolean') {\n        this.isStale = config.initialStale\n      } else {\n        this.isStale = typeof query.state.data === 'undefined'\n      }\n    } else {\n      this.isStale = query.isStaleByTime(config.staleTime)\n    }\n\n    this.updateResult()\n\n    if (this.listener) {\n      prevQuery?.unsubscribeObserver(this)\n      this.currentQuery.subscribeObserver(this)\n    }\n  }\n\n  onQueryUpdate(action: Action<TResult, TError>): void {\n    const { config } = this\n    const { type } = action\n\n    // Update stale state on success, error or invalidation\n    if (type === 2 || type === 3 || type === 4) {\n      this.isStale = this.currentQuery.isStaleByTime(config.staleTime)\n    }\n\n    // Store current result and get new result\n    const prevResult = this.currentResult\n    this.updateResult()\n    const currentResult = this.currentResult\n\n    // Update timers on success, error or invalidation\n    if (type === 2 || type === 3 || type === 4) {\n      this.updateTimers()\n    }\n\n    // Do not notify if the query was invalidated but the stale state did not changed\n    if (type === 4 && currentResult.isStale === prevResult.isStale) {\n      return\n    }\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {}\n\n    if (type === 2) {\n      notifyOptions.onSuccess = true\n    } else if (type === 3) {\n      notifyOptions.onError = true\n    }\n\n    if (\n      // Always notify if notifyOnStatusChange is set\n      config.notifyOnStatusChange ||\n      // Otherwise only notify on data or error change\n      currentResult.data !== prevResult.data ||\n      currentResult.error !== prevResult.error\n    ) {\n      notifyOptions.listener = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  private notify(options: NotifyOptions): void {\n    const { config, currentResult, currentQuery, listener } = this\n    const { onSuccess, onSettled, onError } = config\n\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (options.onSuccess) {\n        if (onSuccess) {\n          notifyManager.schedule(() => {\n            onSuccess(currentResult.data!)\n          })\n        }\n        if (onSettled) {\n          notifyManager.schedule(() => {\n            onSettled(currentResult.data!, null)\n          })\n        }\n      } else if (options.onError) {\n        if (onError) {\n          notifyManager.schedule(() => {\n            onError(currentResult.error!)\n          })\n        }\n        if (onSettled) {\n          notifyManager.schedule(() => {\n            onSettled(undefined, currentResult.error!)\n          })\n        }\n      }\n\n      // Then trigger the listener\n      if (options.listener && listener) {\n        notifyManager.schedule(() => {\n          listener(currentResult)\n        })\n      }\n\n      // Then the global listeners\n      if (options.globalListeners) {\n        config.queryCache.notifyGlobalListeners(currentQuery)\n      }\n    })\n  }\n}\n","import {\n  CancelledError,\n  Console,\n  Updater,\n  functionalUpdate,\n  isCancelable,\n  isCancelledError,\n  isDocumentVisible,\n  isOnline,\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceEqualDeep,\n  sleep,\n} from './utils'\nimport {\n  ArrayQueryKey,\n  InitialDataFunction,\n  IsFetchingMoreValue,\n  QueryFunction,\n  QueryStatus,\n  ResolvedQueryConfig,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport { QueryObserver, UpdateListener } from './queryObserver'\nimport { notifyManager } from './notifyManager'\n\n// TYPES\n\nexport interface QueryState<TResult, TError> {\n  canFetchMore?: boolean\n  data?: TResult\n  error: TError | null\n  failureCount: number\n  isFetching: boolean\n  isFetchingMore: IsFetchingMoreValue\n  isInitialData: boolean\n  isInvalidated: boolean\n  status: QueryStatus\n  throwInErrorBoundary?: boolean\n  updateCount: number\n  updatedAt: number\n}\n\ninterface FetchOptions {\n  fetchMore?: FetchMoreOptions\n}\n\nexport interface FetchMoreOptions {\n  fetchMoreVariable?: unknown\n  previous: boolean\n}\n\nexport interface RefetchOptions {\n  throwOnError?: boolean\n}\n\nconst enum ActionType {\n  Failed,\n  Fetch,\n  Success,\n  Error,\n  Invalidate,\n}\n\ninterface SetDataOptions {\n  updatedAt?: number\n}\n\ninterface FailedAction {\n  type: ActionType.Failed\n}\n\ninterface FetchAction {\n  type: ActionType.Fetch\n  isFetchingMore?: IsFetchingMoreValue\n}\n\ninterface SuccessAction<TResult> {\n  type: ActionType.Success\n  data: TResult | undefined\n  canFetchMore?: boolean\n  updatedAt?: number\n}\n\ninterface ErrorAction<TError> {\n  type: ActionType.Error\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: ActionType.Invalidate\n}\n\nexport type Action<TResult, TError> =\n  | ErrorAction<TError>\n  | FailedAction\n  | FetchAction\n  | InvalidateAction\n  | SuccessAction<TResult>\n\n// CLASS\n\nexport class Query<TResult, TError> {\n  queryKey: ArrayQueryKey\n  queryHash: string\n  config: ResolvedQueryConfig<TResult, TError>\n  observers: QueryObserver<TResult, TError>[]\n  state: QueryState<TResult, TError>\n  cacheTime: number\n\n  private queryCache: QueryCache\n  private promise?: Promise<TResult>\n  private gcTimeout?: number\n  private cancelFetch?: (silent?: boolean) => void\n  private continueFetch?: () => void\n  private isTransportCancelable?: boolean\n\n  constructor(config: ResolvedQueryConfig<TResult, TError>) {\n    this.config = config\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.queryCache = config.queryCache\n    this.cacheTime = config.cacheTime\n    this.observers = []\n    this.state = getDefaultState(config)\n    this.scheduleGc()\n  }\n\n  private updateConfig(config: ResolvedQueryConfig<TResult, TError>): void {\n    this.config = config\n    this.cacheTime = Math.max(this.cacheTime, config.cacheTime)\n  }\n\n  private dispatch(action: Action<TResult, TError>): void {\n    this.state = queryReducer(this.state, action)\n\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action)\n      })\n\n      this.queryCache.notifyGlobalListeners(this)\n    })\n  }\n\n  private scheduleGc(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearGcTimeout()\n\n    if (this.observers.length > 0 || !isValidTimeout(this.cacheTime)) {\n      return\n    }\n\n    this.gcTimeout = setTimeout(() => {\n      this.remove()\n    }, this.cacheTime)\n  }\n\n  cancel(silent?: boolean): Promise<undefined> {\n    const promise = this.promise\n\n    if (promise && this.cancelFetch) {\n      this.cancelFetch(silent)\n      return promise.then(noop).catch(noop)\n    }\n\n    return Promise.resolve(undefined)\n  }\n\n  private continue(): void {\n    this.continueFetch?.()\n  }\n\n  private clearTimersObservers(): void {\n    this.observers.forEach(observer => {\n      observer.clearTimers()\n    })\n  }\n\n  private clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout)\n      this.gcTimeout = undefined\n    }\n  }\n\n  setData(\n    updater: Updater<TResult | undefined, TResult>,\n    options?: SetDataOptions\n  ): void {\n    const prevData = this.state.data\n\n    // Get the new data\n    let data: TResult | undefined = functionalUpdate(updater, prevData)\n\n    // Use prev data if an isDataEqual function is defined and returns `true`\n    if (this.config.isDataEqual?.(prevData, data)) {\n      data = prevData\n    } else if (this.config.structuralSharing) {\n      // Structurally share data between prev and new data if needed\n      data = replaceEqualDeep(prevData, data)\n    }\n\n    // Try to determine if more data can be fetched\n    const canFetchMore = hasMorePages(this.config, data)\n\n    // Set data and mark it as cached\n    this.dispatch({\n      type: ActionType.Success,\n      data,\n      canFetchMore,\n      updatedAt: options?.updatedAt,\n    })\n  }\n\n  /**\n   * @deprecated\n   */\n  clear(): void {\n    Console.warn(\n      'react-query: clear() has been deprecated, please use remove() instead'\n    )\n    this.remove()\n  }\n\n  remove(): void {\n    this.queryCache.removeQuery(this)\n  }\n\n  destroy(): void {\n    this.clearGcTimeout()\n    this.clearTimersObservers()\n    this.cancel()\n  }\n\n  isActive(): boolean {\n    return this.observers.some(observer => observer.config.enabled)\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      this.state.status !== QueryStatus.Success ||\n      this.observers.some(observer => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      this.state.status !== QueryStatus.Success ||\n      this.state.updatedAt + staleTime <= Date.now()\n    )\n  }\n\n  onInteraction(type: 'focus' | 'online'): void {\n    // Execute the first observer which is enabled,\n    // stale and wants to refetch on this interaction.\n    const staleObserver = this.observers.find(observer => {\n      const { config } = observer\n      const { isStale } = observer.getCurrentResult()\n      return (\n        config.enabled &&\n        ((type === 'focus' &&\n          (config.refetchOnWindowFocus === 'always' ||\n            (config.refetchOnWindowFocus && isStale))) ||\n          (type === 'online' &&\n            (config.refetchOnReconnect === 'always' ||\n              (config.refetchOnReconnect && isStale))))\n      )\n    })\n\n    if (staleObserver) {\n      staleObserver.fetch()\n    }\n\n    // Continue any paused fetch\n    this.continue()\n  }\n\n  /**\n   * @deprectated\n   */\n  subscribe(\n    listener?: UpdateListener<TResult, TError>\n  ): QueryObserver<TResult, TError> {\n    const observer = new QueryObserver(this.config)\n    observer.subscribe(listener)\n    return observer\n  }\n\n  subscribeObserver(observer: QueryObserver<TResult, TError>): void {\n    this.observers.push(observer)\n\n    // Stop the query from being garbage collected\n    this.clearGcTimeout()\n  }\n\n  unsubscribeObserver(observer: QueryObserver<TResult, TError>): void {\n    this.observers = this.observers.filter(x => x !== observer)\n\n    if (!this.observers.length) {\n      // If the transport layer does not support cancellation\n      // we'll let the query continue so the result can be cached\n      if (this.isTransportCancelable) {\n        this.cancel()\n      }\n\n      this.scheduleGc()\n    }\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: ActionType.Invalidate })\n    }\n  }\n\n  /**\n   * @deprectated\n   */\n  refetch(\n    options?: RefetchOptions,\n    config?: ResolvedQueryConfig<TResult, TError>\n  ): Promise<TResult | undefined> {\n    let promise: Promise<TResult | undefined> = this.fetch(undefined, config)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  /**\n   * @deprectated\n   */\n  fetchMore(\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions,\n    config?: ResolvedQueryConfig<TResult, TError>\n  ): Promise<TResult | undefined> {\n    return this.fetch(\n      {\n        fetchMore: {\n          fetchMoreVariable,\n          previous: options?.previous || false,\n        },\n      },\n      config\n    )\n  }\n\n  async fetch(\n    options?: FetchOptions,\n    config?: ResolvedQueryConfig<TResult, TError>\n  ): Promise<TResult> {\n    if (this.promise) {\n      if (options?.fetchMore && this.state.data) {\n        // Silently cancel current fetch if the user wants to fetch more\n        await this.cancel(true)\n      } else {\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (config) {\n      this.updateConfig(config)\n    }\n\n    config = this.config\n\n    // Get the query function params\n    const filter = config.queryFnParamsFilter\n    const params = filter ? filter(this.queryKey) : this.queryKey\n\n    this.promise = (async () => {\n      try {\n        let data: any\n\n        if (config.infinite) {\n          data = await this.startInfiniteFetch(config, params, options)\n        } else {\n          data = await this.startFetch(config, params, options)\n        }\n\n        // Set success state\n        this.setData(data)\n\n        // Cleanup\n        delete this.promise\n\n        // Return data\n        return data\n      } catch (error) {\n        // Set error state if needed\n        if (!(isCancelledError(error) && error.silent)) {\n          this.dispatch({\n            type: ActionType.Error,\n            error,\n          })\n        }\n\n        // Log error\n        if (!isCancelledError(error)) {\n          Console.error(error)\n        }\n\n        // Cleanup\n        delete this.promise\n\n        // Propagate error\n        throw error\n      }\n    })()\n\n    return this.promise\n  }\n\n  private startFetch(\n    config: ResolvedQueryConfig<TResult, TError>,\n    params: unknown[],\n    _options?: FetchOptions\n  ): Promise<TResult> {\n    // Create function to fetch the data\n    const fetchData = () => config.queryFn(...params)\n\n    // Set to fetching state if not already in it\n    if (!this.state.isFetching) {\n      this.dispatch({ type: ActionType.Fetch })\n    }\n\n    // Try to fetch the data\n    return this.tryFetchData(config, fetchData)\n  }\n\n  private startInfiniteFetch(\n    config: ResolvedQueryConfig<TResult, TError>,\n    params: unknown[],\n    options?: FetchOptions\n  ): Promise<TResult[]> {\n    const fetchMore = options?.fetchMore\n    const { previous, fetchMoreVariable } = fetchMore || {}\n    const isFetchingMore = fetchMore ? (previous ? 'previous' : 'next') : false\n    const prevPages: TResult[] = (this.state.data as any) || []\n\n    // Create function to fetch a page\n    const fetchPage = async (\n      pages: TResult[],\n      prepend?: boolean,\n      cursor?: unknown\n    ) => {\n      const lastPage = getLastPage(pages, prepend)\n\n      if (\n        typeof cursor === 'undefined' &&\n        typeof lastPage !== 'undefined' &&\n        config.getFetchMore\n      ) {\n        cursor = config.getFetchMore(lastPage, pages)\n      }\n\n      if (!Boolean(cursor) && typeof lastPage !== 'undefined') {\n        return pages\n      }\n\n      const page = await config.queryFn(...params, cursor)\n\n      return prepend ? [page, ...pages] : [...pages, page]\n    }\n\n    // Create function to fetch the data\n    const fetchData = () => {\n      if (isFetchingMore) {\n        return fetchPage(prevPages, previous, fetchMoreVariable)\n      } else if (!prevPages.length) {\n        return fetchPage([])\n      } else {\n        let promise = fetchPage([])\n        for (let i = 1; i < prevPages.length; i++) {\n          promise = promise.then(fetchPage)\n        }\n        return promise\n      }\n    }\n\n    // Set to fetching state if not already in it\n    if (\n      !this.state.isFetching ||\n      this.state.isFetchingMore !== isFetchingMore\n    ) {\n      this.dispatch({ type: ActionType.Fetch, isFetchingMore })\n    }\n\n    // Try to get the data\n    return this.tryFetchData(config, fetchData)\n  }\n\n  private tryFetchData<T>(\n    config: ResolvedQueryConfig<TResult, TError>,\n    fn: QueryFunction<T>\n  ): Promise<T> {\n    return new Promise<T>((outerResolve, outerReject) => {\n      let resolved = false\n      let continueLoop: () => void\n      let cancelTransport: () => void\n\n      const done = () => {\n        resolved = true\n\n        delete this.cancelFetch\n        delete this.continueFetch\n        delete this.isTransportCancelable\n\n        // End loop if currently paused\n        continueLoop?.()\n      }\n\n      const resolve = (value: any) => {\n        done()\n        outerResolve(value)\n      }\n\n      const reject = (value: any) => {\n        done()\n        outerReject(value)\n      }\n\n      // Create callback to cancel this fetch\n      this.cancelFetch = silent => {\n        reject(new CancelledError(silent))\n        cancelTransport?.()\n      }\n\n      // Create callback to continue this fetch\n      this.continueFetch = () => {\n        continueLoop?.()\n      }\n\n      // Create loop function\n      const run = async () => {\n        try {\n          // Execute query\n          const promiseOrValue = fn()\n\n          // Check if the transport layer support cancellation\n          if (isCancelable(promiseOrValue)) {\n            cancelTransport = () => {\n              try {\n                promiseOrValue.cancel()\n              } catch {}\n            }\n            this.isTransportCancelable = true\n          }\n\n          // Await data\n          resolve(await promiseOrValue)\n        } catch (error) {\n          // Stop if the fetch is already resolved\n          if (resolved) {\n            return\n          }\n\n          // Do we need to retry the request?\n          const { failureCount } = this.state\n          const { retry, retryDelay } = config\n\n          const shouldRetry =\n            retry === true ||\n            failureCount < retry! ||\n            (typeof retry === 'function' && retry(failureCount, error))\n\n          if (!shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error)\n            return\n          }\n\n          // Increase the failureCount\n          this.dispatch({ type: ActionType.Failed })\n\n          // Delay\n          await sleep(functionalUpdate(retryDelay, failureCount) || 0)\n\n          // Pause retry if the document is not visible or when the device is offline\n          if (!isDocumentVisible() || !isOnline()) {\n            await new Promise(continueResolve => {\n              continueLoop = continueResolve\n            })\n          }\n\n          // Try again if not resolved yet\n          if (!resolved) {\n            run()\n          }\n        }\n      }\n\n      // Start loop\n      run()\n    })\n  }\n}\n\nfunction getLastPage<TResult>(pages: TResult[], previous?: boolean): TResult {\n  return previous ? pages[0] : pages[pages.length - 1]\n}\n\nfunction hasMorePages<TResult, TError>(\n  config: ResolvedQueryConfig<TResult, TError>,\n  pages: unknown,\n  previous?: boolean\n): boolean | undefined {\n  if (config.infinite && config.getFetchMore && Array.isArray(pages)) {\n    return Boolean(config.getFetchMore(getLastPage(pages, previous), pages))\n  }\n}\n\nfunction getDefaultState<TResult, TError>(\n  config: ResolvedQueryConfig<TResult, TError>\n): QueryState<TResult, TError> {\n  const data =\n    typeof config.initialData === 'function'\n      ? (config.initialData as InitialDataFunction<TResult>)()\n      : config.initialData\n\n  const status =\n    typeof data !== 'undefined'\n      ? QueryStatus.Success\n      : config.enabled\n      ? QueryStatus.Loading\n      : QueryStatus.Idle\n\n  return {\n    canFetchMore: hasMorePages(config, data),\n    data,\n    error: null,\n    failureCount: 0,\n    isFetching: status === QueryStatus.Loading,\n    isFetchingMore: false,\n    isInitialData: true,\n    isInvalidated: false,\n    status,\n    updateCount: 0,\n    updatedAt: Date.now(),\n  }\n}\n\nexport function queryReducer<TResult, TError>(\n  state: QueryState<TResult, TError>,\n  action: Action<TResult, TError>\n): QueryState<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Failed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case ActionType.Fetch:\n      return {\n        ...state,\n        failureCount: 0,\n        isFetching: true,\n        isFetchingMore: action.isFetchingMore || false,\n        status:\n          typeof state.data !== 'undefined'\n            ? QueryStatus.Success\n            : QueryStatus.Loading,\n      }\n    case ActionType.Success:\n      return {\n        ...state,\n        canFetchMore: action.canFetchMore,\n        data: action.data,\n        error: null,\n        failureCount: 0,\n        isFetching: false,\n        isFetchingMore: false,\n        isInitialData: false,\n        isInvalidated: false,\n        status: QueryStatus.Success,\n        updateCount: state.updateCount + 1,\n        updatedAt: action.updatedAt ?? Date.now(),\n      }\n    case ActionType.Error:\n      return {\n        ...state,\n        error: action.error,\n        failureCount: state.failureCount + 1,\n        isFetching: false,\n        isFetchingMore: false,\n        status: QueryStatus.Error,\n        throwInErrorBoundary: true,\n        updateCount: state.updateCount + 1,\n      }\n    case ActionType.Invalidate:\n      return {\n        ...state,\n        isInvalidated: true,\n      }\n    default:\n      return state\n  }\n}\n","import {\n  Updater,\n  deepIncludes,\n  getQueryArgs,\n  isDocumentVisible,\n  isOnline,\n  isPlainObject,\n  isServer,\n  noop,\n} from './utils'\nimport { getResolvedQueryConfig } from './config'\nimport { Query } from './query'\nimport {\n  QueryConfig,\n  QueryFunction,\n  QueryKey,\n  ReactQueryConfig,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n  ResolvedQueryConfig,\n} from './types'\nimport { notifyManager } from './notifyManager'\nimport { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  frozen?: boolean\n  defaultConfig?: ReactQueryConfig\n}\n\ninterface ClearOptions {\n  notify?: boolean\n}\n\ninterface PrefetchQueryOptions {\n  force?: boolean\n  throwOnError?: boolean\n}\n\ninterface RefetchQueriesOptions extends QueryPredicateOptions {\n  throwOnError?: boolean\n}\n\ninterface InvalidateQueriesOptions extends RefetchQueriesOptions {\n  refetchActive?: boolean\n  refetchInactive?: boolean\n}\n\ninterface QueryPredicateOptions {\n  active?: boolean\n  exact?: boolean\n  stale?: boolean\n}\n\ntype QueryPredicate = QueryKey | QueryPredicateFn | true\n\ntype QueryPredicateFn = (query: Query<unknown, unknown>) => boolean\n\nexport interface FetchQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: QueryConfig<TResult, TError>\n}\n\nexport interface PrefetchQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: QueryConfig<TResult, TError>\n  options?: PrefetchQueryOptions\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any>\n}\n\ntype QueryCacheListener = (\n  cache: QueryCache,\n  query?: Query<unknown, unknown>\n) => void\n\n// CLASS\n\nexport class QueryCache {\n  isFetching: number\n\n  private config: QueryCacheConfig\n  private globalListeners: QueryCacheListener[]\n  private queries: QueryHashMap\n  private queriesArray: Query<any, any>[]\n\n  constructor(config?: QueryCacheConfig) {\n    this.config = config || {}\n    this.globalListeners = []\n    this.queries = {}\n    this.queriesArray = []\n    this.isFetching = 0\n  }\n\n  notifyGlobalListeners(query?: Query<any, any>) {\n    this.isFetching = this.getQueries().reduce(\n      (acc, q) => (q.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    notifyManager.batch(() => {\n      this.globalListeners.forEach(listener => {\n        notifyManager.schedule(() => {\n          listener(this, query)\n        })\n      })\n    })\n  }\n\n  getDefaultConfig() {\n    return this.config.defaultConfig\n  }\n\n  getResolvedQueryConfig<TResult, TError>(\n    queryKey: QueryKey,\n    config?: QueryConfig<TResult, TError>\n  ): ResolvedQueryConfig<TResult, TError> {\n    return getResolvedQueryConfig(this, queryKey, undefined, config)\n  }\n\n  subscribe(listener: QueryCacheListener): () => void {\n    this.globalListeners.push(listener)\n    return () => {\n      this.globalListeners = this.globalListeners.filter(x => x !== listener)\n    }\n  }\n\n  clear(options?: ClearOptions): void {\n    this.removeQueries()\n    if (options?.notify) {\n      this.notifyGlobalListeners()\n    }\n  }\n\n  getQueries<TResult = unknown, TError = unknown>(\n    predicate?: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): Query<TResult, TError>[] {\n    const anyKey = predicate === true || typeof predicate === 'undefined'\n\n    if (anyKey && !options) {\n      return this.queriesArray\n    }\n\n    let predicateFn: QueryPredicateFn\n\n    if (typeof predicate === 'function') {\n      predicateFn = predicate as QueryPredicateFn\n    } else {\n      const { exact, active, stale } = options || {}\n      const resolvedConfig = this.getResolvedQueryConfig(predicate)\n\n      predicateFn = query => {\n        // Check query key if needed\n        if (!anyKey) {\n          if (exact) {\n            // Check if the query key matches exactly\n            if (query.queryHash !== resolvedConfig.queryHash) {\n              return false\n            }\n          } else {\n            // Check if the query key matches partially\n            if (!deepIncludes(query.queryKey, resolvedConfig.queryKey)) {\n              return false\n            }\n          }\n        }\n\n        // Check active state if needed\n        if (typeof active === 'boolean' && query.isActive() !== active) {\n          return false\n        }\n\n        // Check stale state if needed\n        if (typeof stale === 'boolean' && query.isStale() !== stale) {\n          return false\n        }\n\n        return true\n      }\n    }\n\n    return this.queriesArray.filter(predicateFn)\n  }\n\n  getQuery<TResult, TError = unknown>(\n    predicate: QueryPredicate\n  ): Query<TResult, TError> | undefined {\n    return this.getQueries<TResult, TError>(predicate, { exact: true })[0]\n  }\n\n  getQueryByHash<TResult, TError = unknown>(\n    queryHash: string\n  ): Query<TResult, TError> | undefined {\n    return this.queries[queryHash]\n  }\n\n  getQueryData<TResult>(predicate: QueryPredicate): TResult | undefined {\n    return this.getQuery<TResult>(predicate)?.state.data\n  }\n\n  removeQuery(query: Query<any, any>): void {\n    if (this.queries[query.queryHash]) {\n      query.destroy()\n      delete this.queries[query.queryHash]\n      this.queriesArray = this.queriesArray.filter(x => x !== query)\n      this.notifyGlobalListeners(query)\n    }\n  }\n\n  removeQueries(\n    predicate?: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => {\n      this.removeQuery(query)\n    })\n  }\n\n  cancelQueries(\n    predicate?: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => {\n      query.cancel()\n    })\n  }\n\n  /**\n   * @return Promise resolving to an array with the invalidated queries.\n   */\n  invalidateQueries(\n    predicate?: QueryPredicate,\n    options?: InvalidateQueriesOptions\n  ): Promise<Query<unknown, unknown>[]> {\n    const queries = this.getQueries(predicate, options)\n\n    notifyManager.batch(() => {\n      queries.forEach(query => {\n        query.invalidate()\n      })\n    })\n\n    const { refetchActive = true, refetchInactive = false } = options || {}\n\n    if (!refetchInactive && !refetchActive) {\n      return Promise.resolve(queries)\n    }\n\n    const refetchOptions: RefetchQueriesOptions = { ...options }\n\n    if (refetchActive && !refetchInactive) {\n      refetchOptions.active = true\n    } else if (refetchInactive && !refetchActive) {\n      refetchOptions.active = false\n    }\n\n    let promise = this.refetchQueries(predicate, refetchOptions)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(() => queries)\n    }\n\n    return promise.then(() => queries)\n  }\n\n  /**\n   * @return Promise resolving to an array with the refetched queries.\n   */\n  refetchQueries(\n    predicate?: QueryPredicate,\n    options?: RefetchQueriesOptions\n  ): Promise<Query<unknown, unknown>[]> {\n    const promises: Promise<Query<unknown, unknown>>[] = []\n\n    notifyManager.batch(() => {\n      this.getQueries(predicate, options).forEach(query => {\n        let promise = query.fetch().then(() => query)\n\n        if (!options?.throwOnError) {\n          promise = promise.catch(() => query)\n        }\n\n        promises.push(promise)\n      })\n    })\n\n    return Promise.all(promises)\n  }\n\n  resetErrorBoundaries(): void {\n    this.getQueries().forEach(query => {\n      query.state.throwInErrorBoundary = false\n    })\n  }\n\n  buildQuery<TResult, TError = unknown>(\n    queryKey: QueryKey,\n    config?: QueryConfig<TResult, TError>\n  ): Query<TResult, TError> {\n    const resolvedConfig = this.getResolvedQueryConfig(queryKey, config)\n    let query = this.getQueryByHash<TResult, TError>(resolvedConfig.queryHash)\n\n    if (!query) {\n      query = this.createQuery(resolvedConfig)\n    }\n\n    return query\n  }\n\n  createQuery<TResult, TError = unknown>(\n    config: ResolvedQueryConfig<TResult, TError>\n  ): Query<TResult, TError> {\n    const query = new Query(config)\n\n    // A frozen cache does not add new queries to the cache\n    if (!this.config.frozen) {\n      this.queries[query.queryHash] = query\n      this.queriesArray.push(query)\n      this.notifyGlobalListeners(query)\n    }\n\n    return query\n  }\n\n  // Parameter syntax\n  fetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): Promise<TResult>\n\n  // Parameter syntax with query function\n  fetchQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n    queryKey: QueryKey,\n    queryFn: TypedQueryFunction<TResult, TArgs>,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): Promise<TResult>\n\n  fetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TResult>,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): Promise<TResult>\n\n  // Object syntax\n  fetchQuery<TResult = unknown, TError = unknown>(\n    config: FetchQueryObjectConfig<TResult, TError>\n  ): Promise<TResult>\n\n  // Implementation\n  fetchQuery<TResult, TError>(\n    arg1: any,\n    arg2?: any,\n    arg3?: any\n  ): Promise<TResult> {\n    const [queryKey, config] = getQueryArgs<TResult, TError>(arg1, arg2, arg3)\n\n    const resolvedConfig = this.getResolvedQueryConfig(queryKey, {\n      // https://github.com/tannerlinsley/react-query/issues/652\n      retry: false,\n      ...config,\n    })\n\n    let query = this.getQueryByHash<TResult, TError>(resolvedConfig.queryHash)\n\n    if (!query) {\n      query = this.createQuery(resolvedConfig)\n    }\n\n    if (!query.isStaleByTime(config.staleTime)) {\n      return Promise.resolve(query.state.data as TResult)\n    }\n\n    return query.fetch(undefined, resolvedConfig)\n  }\n\n  // Parameter syntax with optional prefetch options\n  prefetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function and optional prefetch options\n  prefetchQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n    queryKey: QueryKey,\n    queryFn: TypedQueryFunction<TResult, TArgs>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  prefetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TResult>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function, config and optional prefetch options\n  prefetchQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n    queryKey: QueryKey,\n    queryFn: TypedQueryFunction<TResult, TArgs>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  prefetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TResult>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Object syntax\n  prefetchQuery<TResult = unknown, TError = unknown>(\n    config: PrefetchQueryObjectConfig<TResult, TError>\n  ): Promise<TResult | undefined>\n\n  // Implementation\n  prefetchQuery<TResult, TError>(\n    arg1: any,\n    arg2?: any,\n    arg3?: any,\n    arg4?: any\n  ): Promise<TResult | undefined> {\n    if (\n      isPlainObject(arg2) &&\n      (arg2.hasOwnProperty('throwOnError') || arg2.hasOwnProperty('force'))\n    ) {\n      arg4 = arg2\n      arg2 = undefined\n      arg3 = undefined\n    }\n\n    const [queryKey, config, options] = getQueryArgs<\n      TResult,\n      TError,\n      PrefetchQueryOptions | undefined\n    >(arg1, arg2, arg3, arg4)\n\n    if (options?.force) {\n      config.staleTime = 0\n    }\n\n    let promise: Promise<TResult | undefined> = this.fetchQuery(\n      queryKey,\n      config\n    )\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  // Parameter syntax\n  watchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): QueryObserver<TResult, TError>\n\n  // Parameter syntax with query function\n  watchQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n    queryKey: QueryKey,\n    queryFn: TypedQueryFunction<TResult, TArgs>,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): QueryObserver<TResult, TError>\n\n  watchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TResult>,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): QueryObserver<TResult, TError>\n\n  // Implementation\n  watchQuery<TResult, TError>(\n    arg1: any,\n    arg2?: any,\n    arg3?: any\n  ): QueryObserver<TResult, TError> {\n    const [queryKey, config] = getQueryArgs<TResult, TError>(arg1, arg2, arg3)\n    const resolvedConfig = this.getResolvedQueryConfig(queryKey, config)\n    return new QueryObserver(resolvedConfig)\n  }\n\n  setQueryData<TResult, TError = unknown>(\n    queryKey: QueryKey,\n    updater: Updater<TResult | undefined, TResult>,\n    config?: QueryConfig<TResult, TError>\n  ) {\n    this.buildQuery(queryKey, config).setData(updater)\n  }\n}\n\nconst defaultQueryCache = new QueryCache({ frozen: isServer })\nexport { defaultQueryCache as queryCache }\nexport const queryCaches = [defaultQueryCache]\n\n/**\n * @deprecated\n */\nexport function makeQueryCache(config?: QueryCacheConfig) {\n  return new QueryCache(config)\n}\n\nexport function onVisibilityOrOnlineChange(type: 'focus' | 'online') {\n  if (isDocumentVisible() && isOnline()) {\n    notifyManager.batch(() => {\n      queryCaches.forEach(queryCache => {\n        queryCache.getQueries().forEach(query => {\n          query.onInteraction(type)\n        })\n      })\n    })\n  }\n}\n","import { createSetHandler, isServer } from './utils'\nimport { onVisibilityOrOnlineChange } from './queryCache'\n\nexport const setFocusHandler = createSetHandler(() =>\n  onVisibilityOrOnlineChange('focus')\n)\n\nsetFocusHandler(handleFocus => {\n  if (isServer || !window?.addEventListener) {\n    return\n  }\n\n  // Listen to visibillitychange and focus\n  window.addEventListener('visibilitychange', handleFocus, false)\n  window.addEventListener('focus', handleFocus, false)\n\n  return () => {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('visibilitychange', handleFocus)\n    window.removeEventListener('focus', handleFocus)\n  }\n})\n","import { createSetHandler, isServer } from './utils'\nimport { onVisibilityOrOnlineChange } from './queryCache'\n\nexport const setOnlineHandler = createSetHandler(() =>\n  onVisibilityOrOnlineChange('online')\n)\n\nsetOnlineHandler(handleOnline => {\n  if (isServer || !window?.addEventListener) {\n    return\n  }\n\n  // Listen to online\n  window.addEventListener('online', handleOnline, false)\n\n  return () => {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('online', handleOnline)\n  }\n})\n","import ReactDOM from 'react-dom'\nexport const unstable_batchedUpdates = ReactDOM.unstable_batchedUpdates\n","import React from 'react'\n\nimport {\n  QueryCache,\n  queryCache as defaultQueryCache,\n  queryCaches,\n} from '../core'\n\nconst queryCacheContext = React.createContext(defaultQueryCache)\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport interface ReactQueryCacheProviderProps {\n  queryCache?: QueryCache\n}\n\nexport const ReactQueryCacheProvider: React.FC<ReactQueryCacheProviderProps> = ({\n  queryCache,\n  children,\n}) => {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || new QueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear({ notify: false })\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { mergeReactQueryConfigs } from '../core/config'\nimport { ReactQueryConfig } from '../core/types'\n\nconst configContext = React.createContext<ReactQueryConfig | undefined>(\n  undefined\n)\n\nexport function useContextConfig() {\n  return React.useContext(configContext)\n}\n\nexport interface ReactQueryConfigProviderProps {\n  config: ReactQueryConfig\n}\n\nexport const ReactQueryConfigProvider: React.FC<ReactQueryConfigProviderProps> = ({\n  config,\n  children,\n}) => {\n  const parentConfig = useContextConfig()\n\n  const mergedConfig = React.useMemo(\n    () =>\n      parentConfig ? mergeReactQueryConfigs(parentConfig, config) : config,\n    [config, parentConfig]\n  )\n\n  return (\n    <configContext.Provider value={mergedConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n","import React from 'react'\n\n// CONTEXT\n\ninterface ReactQueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): ReactQueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst context = React.createContext(createValue())\n\n// HOOK\n\nexport const useErrorResetBoundary = () => React.useContext(context)\n\n// COMPONENT\n\nexport interface ReactQueryErrorResetBoundaryProps {\n  children:\n    | ((value: ReactQueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const ReactQueryErrorResetBoundary: React.FC<ReactQueryErrorResetBoundaryProps> = ({\n  children,\n}) => {\n  const value = React.useMemo(() => createValue(), [])\n  return (\n    <context.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </context.Provider>\n  )\n}\n","import React from 'react'\n\nimport { isServer } from '../core/utils'\n\nexport function useIsMounted(): () => boolean {\n  const mountedRef = React.useRef(false)\n  const isMounted = React.useCallback(() => mountedRef.current, [])\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mountedRef.current = true\n    return () => {\n      mountedRef.current = false\n    }\n  }, [])\n\n  return isMounted\n}\n\nexport function useMountedCallback<T extends Function>(callback: T): T {\n  const isMounted = useIsMounted()\n  return (React.useCallback(\n    (...args: any[]) => {\n      if (isMounted()) {\n        return callback(...args)\n      }\n    },\n    [callback, isMounted]\n  ) as any) as T\n}\n","import React from 'react'\n\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useIsMounted } from './utils'\n\nexport function useIsFetching(): number {\n  const isMounted = useIsMounted()\n  const queryCache = useQueryCache()\n  const [isFetching, setIsFetching] = React.useState(queryCache.isFetching)\n\n  React.useEffect(\n    () =>\n      queryCache.subscribe(() => {\n        if (isMounted()) {\n          setIsFetching(queryCache.isFetching)\n        }\n      }),\n    [queryCache, setIsFetching, isMounted]\n  )\n\n  return isFetching\n}\n","import React from 'react'\n\nimport { useMountedCallback } from './utils'\nimport { getResolvedMutationConfig } from '../core/config'\nimport { Console, uid, getStatusProps } from '../core/utils'\nimport {\n  QueryStatus,\n  MutationResultPair,\n  MutationFunction,\n  MutationConfig,\n  MutateConfig,\n  MutationResult,\n} from '../core/types'\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useContextConfig } from './ReactQueryConfigProvider'\n\n// TYPES\n\ntype Reducer<S, A> = (prevState: S, action: A) => S\n\ninterface State<TResult, TError> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n}\n\nconst enum ActionType {\n  Reset,\n  Loading,\n  Resolve,\n  Reject,\n}\n\ninterface ResetAction {\n  type: ActionType.Reset\n}\n\ninterface LoadingAction {\n  type: ActionType.Loading\n}\n\ninterface ResolveAction<TResult> {\n  type: ActionType.Resolve\n  data: TResult\n}\n\ninterface RejectAction<TError> {\n  type: ActionType.Reject\n  error: TError\n}\n\ntype Action<TResult, TError> =\n  | ResetAction\n  | LoadingAction\n  | ResolveAction<TResult>\n  | RejectAction<TError>\n\n// HOOK\n\nfunction getDefaultState<TResult, TError>(): State<TResult, TError> {\n  return {\n    ...getStatusProps(QueryStatus.Idle),\n    data: undefined,\n    error: null,\n  }\n}\n\nfunction mutationReducer<TResult, TError>(\n  state: State<TResult, TError>,\n  action: Action<TResult, TError>\n): State<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Reset:\n      return getDefaultState()\n    case ActionType.Loading:\n      return {\n        ...getStatusProps(QueryStatus.Loading),\n        data: undefined,\n        error: null,\n      }\n    case ActionType.Resolve:\n      return {\n        ...getStatusProps(QueryStatus.Success),\n        data: action.data,\n        error: null,\n      }\n    case ActionType.Reject:\n      return {\n        ...getStatusProps(QueryStatus.Error),\n        data: undefined,\n        error: action.error,\n      }\n    default:\n      return state\n  }\n}\n\nexport function useMutation<\n  TResult,\n  TError = unknown,\n  TVariables = undefined,\n  TSnapshot = unknown\n>(\n  mutationFn: MutationFunction<TResult, TVariables>,\n  config: MutationConfig<TResult, TError, TVariables, TSnapshot> = {}\n): MutationResultPair<TResult, TError, TVariables, TSnapshot> {\n  const cache = useQueryCache()\n  const contextConfig = useContextConfig()\n\n  // Get resolved config\n  const resolvedConfig = getResolvedMutationConfig(cache, contextConfig, config)\n\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer as Reducer<State<TResult, TError>, Action<TResult, TError>>,\n    null,\n    getDefaultState\n  )\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const latestMutationRef = React.useRef<number>()\n  const latestMutationFnRef = React.useRef(mutationFn)\n  latestMutationFnRef.current = mutationFn\n  const latestConfigRef = React.useRef(resolvedConfig)\n  latestConfigRef.current = resolvedConfig\n\n  const mutate = React.useCallback(\n    async (\n      variables?: TVariables,\n      mutateConfig: MutateConfig<TResult, TError, TVariables, TSnapshot> = {}\n    ): Promise<TResult | undefined> => {\n      const latestConfig = latestConfigRef.current\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      let snapshotValue: TSnapshot | undefined\n\n      try {\n        dispatch({ type: ActionType.Loading })\n        snapshotValue = (await latestConfig.onMutate?.(variables!)) as TSnapshot\n\n        const latestMutationFn = latestMutationFnRef.current\n        const data = await latestMutationFn(variables!)\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Resolve, data })\n        }\n\n        await latestConfig.onSuccess?.(data, variables!)\n        await mutateConfig.onSuccess?.(data, variables!)\n        await latestConfig.onSettled?.(data, null, variables!)\n        await mutateConfig.onSettled?.(data, null, variables!)\n\n        return data\n      } catch (error) {\n        Console.error(error)\n        await latestConfig.onError?.(error, variables!, snapshotValue!)\n        await mutateConfig.onError?.(error, variables!, snapshotValue!)\n        await latestConfig.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue as TSnapshot\n        )\n        await mutateConfig.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue\n        )\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Reject, error })\n        }\n\n        if (mutateConfig.throwOnError || latestConfig.throwOnError) {\n          throw error\n        }\n      }\n    },\n    [dispatch]\n  )\n\n  React.useEffect(() => {\n    const latestConfig = latestConfigRef.current\n    const { suspense, useErrorBoundary } = latestConfig\n    if ((useErrorBoundary || suspense) && state.error) {\n      throw state.error\n    }\n  }, [state.error])\n\n  const reset = React.useCallback(() => {\n    dispatch({ type: ActionType.Reset })\n  }, [dispatch])\n\n  const result: MutationResult<TResult, TError> = {\n    ...state,\n    reset,\n  }\n\n  return [mutate, result]\n}\n","import React from 'react'\n\nimport { useIsMounted } from './utils'\nimport { getResolvedQueryConfig } from '../core/config'\nimport { QueryObserver } from '../core/queryObserver'\nimport { QueryResultBase, QueryKey, QueryConfig } from '../core/types'\nimport { useErrorResetBoundary } from './ReactQueryErrorResetBoundary'\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useContextConfig } from './ReactQueryConfigProvider'\n\nexport function useBaseQuery<TResult, TError>(\n  queryKey: QueryKey,\n  config?: QueryConfig<TResult, TError>\n): QueryResultBase<TResult, TError> {\n  const [, rerender] = React.useReducer(c => c + 1, 0)\n  const isMounted = useIsMounted()\n  const cache = useQueryCache()\n  const contextConfig = useContextConfig()\n  const errorResetBoundary = useErrorResetBoundary()\n\n  // Get resolved config\n  const resolvedConfig = getResolvedQueryConfig(\n    cache,\n    queryKey,\n    contextConfig,\n    config\n  )\n\n  // Create query observer\n  const observerRef = React.useRef<QueryObserver<TResult, TError>>()\n  const firstRender = !observerRef.current\n  const observer = observerRef.current || new QueryObserver(resolvedConfig)\n  observerRef.current = observer\n\n  // Subscribe to the observer\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n    return observer.subscribe(() => {\n      if (isMounted()) {\n        rerender()\n      }\n    })\n  }, [isMounted, observer, rerender, errorResetBoundary])\n\n  // Update config\n  if (!firstRender) {\n    observer.updateConfig(resolvedConfig)\n  }\n\n  const result = observer.getCurrentResult()\n\n  // Handle suspense\n  if (resolvedConfig.suspense || resolvedConfig.useErrorBoundary) {\n    const query = observer.getCurrentQuery()\n\n    if (\n      result.isError &&\n      !errorResetBoundary.isReset() &&\n      query.state.throwInErrorBoundary\n    ) {\n      throw result.error\n    }\n\n    if (\n      resolvedConfig.enabled &&\n      resolvedConfig.suspense &&\n      !result.isSuccess\n    ) {\n      errorResetBoundary.clearReset()\n      const unsubscribe = observer.subscribe()\n      throw observer.fetch().finally(unsubscribe)\n    }\n  }\n\n  return result\n}\n","import {\n  QueryConfig,\n  QueryFunction,\n  QueryKey,\n  QueryResult,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\nimport { useBaseQuery } from './useBaseQuery'\n\n// TYPES\n\nexport interface UseQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: QueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Object syntax\nexport function useQuery<TResult = unknown, TError = unknown>(\n  config: UseQueryObjectConfig<TResult, TError>\n): QueryResult<TResult, TError>\n  \n// Parameter syntax with optional config\nexport function useQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n  queryKey: QueryKey,\n  queryFn: TypedQueryFunction<TResult, TArgs>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\nexport function useQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TResult>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n\n// Implementation\nexport function useQuery<TResult, TError>(\n  arg1: any,\n  arg2?: any,\n  arg3?: any\n): QueryResult<TResult, TError> {\n  const [queryKey, config] = getQueryArgs<TResult, TError>(arg1, arg2, arg3)\n  return useBaseQuery(queryKey, config)\n}\n","import {\n  PaginatedQueryConfig,\n  PaginatedQueryResult,\n  QueryFunction,\n  QueryKey,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\nimport { useBaseQuery } from './useBaseQuery'\n\n// A paginated query is more like a \"lag\" query, which means\n// as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\n\n// TYPES\n\nexport interface UsePaginatedQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: PaginatedQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Object syntax\nexport function usePaginatedQuery<TResult = unknown, TError = unknown>(\n  config: UsePaginatedQueryObjectConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Parameter syntax with optional config\nexport function usePaginatedQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TArgs extends TypedQueryFunctionArgs\n>(\n  queryKey: QueryKey,\n  queryFn: TypedQueryFunction<TResult, TArgs>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\nexport function usePaginatedQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TResult>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Implementation\nexport function usePaginatedQuery<TResult, TError>(\n  arg1: any,\n  arg2?: any,\n  arg3?: any\n): PaginatedQueryResult<TResult, TError> {\n  const [queryKey, config] = getQueryArgs<TResult, TError>(arg1, arg2, arg3)\n  const result = useBaseQuery(queryKey, {\n    keepPreviousData: true,\n    ...config,\n  })\n  return {\n    ...result,\n    resolvedData: result.data,\n    latestData: result.isPreviousData ? undefined : result.data,\n  }\n}\n","import {\n  InfiniteQueryConfig,\n  InfiniteQueryResult,\n  QueryFunction,\n  QueryKey,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\nimport { useBaseQuery } from './useBaseQuery'\n\n// TYPES\n\nexport interface UseInfiniteQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: InfiniteQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Object syntax\nexport function useInfiniteQuery<TResult = unknown, TError = unknown>(\n  config: UseInfiniteQueryObjectConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n  \n// Parameter syntax with optional config\nexport function useInfiniteQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TArgs extends TypedQueryFunctionArgs\n>(\n  queryKey: QueryKey,\n  queryFn: TypedQueryFunction<TResult, TArgs>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\nexport function useInfiniteQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TResult>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Implementation\nexport function useInfiniteQuery<TResult, TError>(\n  arg1: any,\n  arg2?: any,\n  arg3?: any\n): InfiniteQueryResult<TResult, TError> {\n  const [queryKey, config] = getQueryArgs<TResult[], TError>(arg1, arg2, arg3)\n  return useBaseQuery(queryKey, { ...config, infinite: true })\n}\n","import { setBatchedUpdates } from './core/index'\nimport { unstable_batchedUpdates } from './react/reactBatchedUpdates'\nsetBatchedUpdates(unstable_batchedUpdates)\n\nexport * from './core/index'\nexport * from './react/index'\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","QueryStatus","CancelledError","silent","_uid","isServer","window","noop","Console","console","error","warn","log","setConsole","c","functionalUpdate","updater","input","stableStringifyReplacer","_key","value","Error","isPlainObject","keys","sort","reduce","result","isValidTimeout","Infinity","isDocumentVisible","document","undefined","includes","visibilityState","isOnline","navigator","onLine","getQueryArgs","arg1","arg2","arg3","arg4","queryKey","queryFn","config","options","o","hasObjectPrototype","ctor","constructor","prot","toString","isError","isCancelledError","getStatusProps","status","isLoading","Loading","isSuccess","Success","isIdle","Idle","createSetHandler","fn","removePreviousHandler","callback","scheduleMicrotask","Promise","resolve","then","catch","setTimeout","batchedUpdates","setBatchedUpdates","getBatchedUpdates","DEFAULT_CONFIG","queries","cacheTime","enabled","notifyOnStatusChange","reject","queryKeySerializerFn","arrayQueryKey","Array","isArray","queryHash","JSON","stringify","parse","refetchOnMount","refetchOnReconnect","refetchOnWindowFocus","retry","retryDelay","attemptIndex","Math","min","staleTime","structuralSharing","getDefaultReactQueryConfig","mutations","getResolvedQueryConfig","queryCache","contextConfig","queryCacheConfig","getDefaultConfig","resolvedConfig","shared","notifyManager","queue","transactions","batch","flush","schedule","notify","push","forEach","QueryObserver","isStale","initialUpdateCount","remove","bind","refetch","fetchMore","unsubscribe","updateQuery","subscribe","listener","currentQuery","subscribeObserver","forceFetchOnMount","fetch","optionalFetch","updateTimers","clearTimers","unsubscribeObserver","updateConfig","prevConfig","prevQuery","Boolean","isResolvedQueryConfig","updateStaleTimeout","refetchInterval","updateRefetchInterval","getCurrentQuery","getCurrentResult","currentResult","clear","fetchMoreVariable","_DEFAULT_CONFIG$queri","data","suspense","isFetched","observers","clearStaleTimeout","timeElapsed","Date","now","updatedAt","timeUntilStale","timeout","max","staleTimeoutId","_this","updateResult","globalListeners","clearRefetchInterval","refetchIntervalId","setInterval","_this2","refetchIntervalInBackground","clearTimeout","clearInterval","state","isPreviousData","isPlaceholderData","keepPreviousData","isInitialData","previousQueryResult","_this$previousQueryRe","placeholderData","canFetchMore","failureCount","updateCount","isFetchedAfterMount","isFetching","isFetchingMore","query","getQueryByHash","createQuery","initialStale","isStaleByTime","onQueryUpdate","action","type","prevResult","notifyOptions","onSuccess","onError","onSettled","notifyGlobalListeners","_empty","direct","body","recover","e","f","args","Query","initialData","hasMorePages","isInvalidated","getDefaultState","scheduleGc","dispatch","ActionType","throwInErrorBoundary","queryReducer","observer","clearGcTimeout","gcTimeout","cancel","promise","cancelFetch","continue","continueFetch","clearTimersObservers","setData","prevData","isDataEqual","_this$config$isDataEq","replaceEqualDeep","a","b","array","aSize","bItems","bSize","copy","equalItems","removeQuery","destroy","isActive","some","onInteraction","staleObserver","find","filter","x","isTransportCancelable","invalidate","throwOnError","previous","_this4","queryFnParamsFilter","params","_async","infinite","startInfiniteFetch","startFetch","_options","tryFetchData","prevPages","fetchPage","pages","prepend","cursor","lastPage","getLastPage","getFetchMore","page","outerResolve","outerReject","continueLoop","cancelTransport","resolved","done","_this5","run","promiseOrValue","continueResolve","QueryCache","queriesArray","getQueries","acc","q","defaultConfig","removeQueries","predicate","predicateFn","anyKey","exact","active","stale","deepIncludes","getQuery","getQueryData","_this$getQuery","_this3","cancelQueries","invalidateQueries","refetchActive","refetchInactive","refetchOptions","refetchQueries","promises","all","resetErrorBoundaries","buildQuery","frozen","fetchQuery","prefetchQuery","force","watchQuery","setQueryData","defaultQueryCache","queryCaches","makeQueryCache","onVisibilityOrOnlineChange","setFocusHandler","handleFocus","_window","addEventListener","removeEventListener","setOnlineHandler","handleOnline","unstable_batchedUpdates","ReactDOM","queryCacheContext","React","createContext","useQueryCache","useContext","ReactQueryCacheProvider","children","resolvedQueryCache","useMemo","useEffect","indexOf","splice","Provider","configContext","useContextConfig","ReactQueryConfigProvider","parentConfig","mergedConfig","createValue","isReset","clearReset","reset","context","useErrorResetBoundary","ReactQueryErrorResetBoundary","useIsMounted","mountedRef","useRef","isMounted","useCallback","current","useIsFetching","useState","setIsFetching","_await","mutationReducer","useMutation","mutationFn","getResolvedMutationConfig","useReducer","unsafeDispatch","latestMutationRef","latestMutationFnRef","latestConfigRef","mutate","variables","mutateConfig","latestConfig","mutationId","snapshotValue","isLatest","onMutate","latestMutationFn","useErrorBoundary","useBaseQuery","rerender","cache","errorResetBoundary","observerRef","firstRender","finally","useQuery","usePaginatedQuery","resolvedData","latestData","useInfiniteQuery"],"mappings":"8CAAe,SAASA,WACtBA,EAAWC,OAAOC,QAAU,SAAUC,OAC/B,IAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,KACrCG,EAASF,UAAUD,OAElB,IAAII,KAAOD,EACVN,OAAOQ,UAAUC,eAAeC,KAAKJ,EAAQC,KAC/CL,EAAOK,GAAOD,EAAOC,WAKpBL,IAGOS,MAAMC,KAAMR,eCuKlBS,YAAAA,GAAAA,cAAAA,oBAAAA,gBAAAA,qBAAAA,IAAAA,WChKCC,EAEX,SAAYC,QACLA,OAASA,GAMdC,EAAO,EAKJ,IAAMC,EAA6B,oBAAXC,OAExB,SAASC,KAIT,IAAIC,EAAyBC,SAAW,CAC7CC,MAAOH,EACPI,KAAMJ,EACNK,IAAKL,GAGA,SAASM,EAAWC,GACzBN,EAAUM,EAGL,SAASC,EACdC,EACAC,SAE0B,mBAAZD,EACTA,EAAgDC,GACjDD,EAGN,SAASE,EAAwBC,EAAcC,MACxB,mBAAVA,QACH,IAAIC,aAGRC,EAAcF,GACThC,OAAOmC,KAAKH,GAChBI,OACAC,QAAO,SAACC,EAAQ/B,UACf+B,EAAO/B,GAAOyB,EAAMzB,GACb+B,IACN,IAGAN,EAuBF,SAASO,EAAeP,SACL,iBAAVA,GAAsBA,GAAS,GAAKA,IAAUQ,EAAAA,EAGvD,SAASC,UAEU,oBAAbC,UAGJ,MAACC,EAAW,UAAW,aAAaC,SAASF,SAASG,iBAGxD,SAASC,gBACcH,IAArBI,UAAUC,QAAwBD,UAAUC,OAG9C,SAASC,EACdC,EACAC,EACAC,EACAC,OAEIC,EACAC,EACAC,EACAC,SAEAvB,EAAcgB,IAChBI,EAAWJ,EAAKI,SAChBC,EAAUL,EAAKK,QACfC,EAASN,EAAKM,OACdC,EAAUN,GACDjB,EAAciB,IACvBG,EAAWJ,EACXM,EAASL,EACTM,EAAUL,IAEVE,EAAWJ,EACXK,EAAUJ,EACVK,EAASJ,EACTK,EAAUJ,GAGZG,EAASA,GAAU,GAEfD,IACFC,OAAcA,GAAQD,QAAAA,KAGjB,CAACD,EAAUE,EAAQC,GAuCrB,SAASvB,EAAcwB,OACvBC,EAAmBD,UACf,MAIHE,EAAOF,EAAEG,oBACK,IAATD,SACF,MAIHE,EAAOF,EAAKpD,kBACbmD,EAAmBG,MAKnBA,EAAKrD,eAAe,iBAQ3B,SAASkD,EAAmBD,SACmB,oBAAtC1D,OAAOQ,UAAUuD,SAASrD,KAAKgD,GAOjC,SAASM,EAAQhC,UACfA,aAAiBC,MAGnB,SAASgC,EAAiBjC,UACxBA,aAAiBlB,EASnB,SAASoD,EAAsCC,SAC7C,CACLA,OAAAA,EACAC,UAAWD,IAAWtD,EAAYwD,QAClCC,UAAWH,IAAWtD,EAAY0D,QAClCP,QAASG,IAAWtD,EAAYoB,MAChCuC,OAAQL,IAAWtD,EAAY4D,MAI5B,SAASC,EAAiBC,OAC3BC,SACG,SAACC,GAEFD,GACFA,IAGFA,EAAwBC,EAASF,IAQ9B,SAASG,EAAkBD,GAChCE,QAAQC,UACLC,KAAKJ,GACLK,OAAM,SAAA5D,UACL6D,YAAW,iBACH7D,QAQd,IAAI8D,EAAsC,SAACP,GACzCA,KAIK,SAASQ,EAAkBV,GAChCS,EAAiBT,EAIZ,SAASW,WACPF,ECxQF,IA+BMG,EAAmC,CAC9CC,QAAS,CACPC,UAAW,IACXC,SAAS,EACTC,sBAAsB,EACtBpC,QAAS,kBAAMwB,QAAQa,UACvBC,qBArCmE,SACrEvC,WAGMwC,EAA+BC,MAAMC,QAAQ1C,GAC7CA,EACA,CAACA,GACC2C,GDmDsBjE,ECnDM8D,EDoD7BI,KAAKC,UAAUnE,EAAOF,UClDpB,CAACmE,EADRH,EAAgBI,KAAKE,MAAMH,IAE3B,eACM,IAAIhE,MAAM,kCD+Cb,IAAyBD,GCpB5BqE,gBAAgB,EAChBC,oBAAoB,EACpBC,sBAAsB,EACtBC,MAAO,EACPC,WAAY,SAAAC,UAAgBC,KAAKC,IAAI,aAAO,EAAKF,GAAc,MAC/DG,UAAW,EACXC,mBAAmB,IAIhB,SAASC,UACP,CACLvB,aAAcD,EAAeC,SAC7BwB,eAAgBzB,EAAeyB,YAwB5B,SAASC,EACdC,EACA5D,EACA6D,EACA3D,OAEM4D,EAAmBF,EAAWG,mBAE9BC,OACD/B,EAAeC,cACf4B,SAAAA,EAAkBG,aAClBH,SAAAA,EAAkB5B,cAClB2B,SAAAA,EAAeI,aACfJ,SAAAA,EAAe3B,QACfhC,GAGClB,EAASgF,EAAezB,qBAAqBvC,UAEnDgE,EAAeJ,WAAaA,EAC5BI,EAAerB,UAAY3D,EAAO,GAClCgF,EAAehE,SAAWhB,EAAO,GAE1BgF,MC/DIE,EAAgB,iCA1CpBC,MAAQ,QACRC,aAAe,6BAGtBC,MAAA,SAAS9C,QACF6C,mBACCpF,EAASuC,gBACV6C,eACA9G,KAAK8G,mBACHE,QAEAtF,KAGTuF,SAAA,SAASC,GACHlH,KAAK8G,kBACFD,MAAMM,KAAKD,GAEhBhD,GAAkB,WAChBgD,UAKNF,MAAA,eACQH,EAAQ7G,KAAK6G,WACdA,MAAQ,GACTA,EAAMpH,QACRyE,GAAkB,WACOQ,GACvBF,EAAe,WACbqC,EAAMO,SAAQ,SAAAF,GACZA,oBChBCG,wBAYCzE,QACLA,OAASA,OACT0E,SAAU,OACVC,mBAAqB,OAGrBC,OAASxH,KAAKwH,OAAOC,KAAKzH,WAC1B0H,QAAU1H,KAAK0H,QAAQD,KAAKzH,WAC5B2H,UAAY3H,KAAK2H,UAAUF,KAAKzH,WAChC4H,YAAc5H,KAAK4H,YAAYH,KAAKzH,WAGpC6H,yCAGPC,UAAA,SAAUC,eACHA,SAAWA,GAAYxH,OACvByH,aAAaC,kBAAkBjI,MAGlCA,KAAK4C,OAAOkC,UACX9E,KAAK4C,OAAOsF,mBAAoD,WAA/BlI,KAAK4C,OAAO6C,qBAEzC0C,aAEAC,qBAGFC,eAEErI,KAAK4H,eAGdA,YAAA,gBACOG,cAAWhG,OACXuG,mBACAN,aAAaO,oBAAoBvI,SAGxCwI,aAAA,SACE5F,OAEM6F,EAAazI,KAAK4C,OAClB8F,EAAY1I,KAAKgI,qBAElBpF,OFmCF,SACLA,UAEO+F,QAAQ/F,EAAOyC,WEtCNuD,CAAsBhG,GAChCA,EACA5C,KAAK4C,OAAO0D,WAAWD,uBACrBrG,KAAK4C,OAAOF,SACZE,QAGDiF,cAGA7H,KAAK+H,aAKN/H,KAAKgI,eAAiBU,cACnBN,0BACAC,eAKHzF,EAAOkC,UAAY2D,EAAW3D,cAC3BsD,gBAKLxF,EAAOkC,UAAY2D,EAAW3D,SAC9BlC,EAAOqD,YAAcwC,EAAWxC,gBAE3B4C,qBAKLjG,EAAOkC,UAAY2D,EAAW3D,SAC9BlC,EAAOkG,kBAAoBL,EAAWK,sBAEjCC,4BAITC,gBAAA,kBACShJ,KAAKgI,gBAGdiB,iBAAA,kBACSjJ,KAAKkJ,iBAMdC,MAAA,gBACO3B,YAGPA,OAAA,gBACOQ,aAAaR,YAGpBE,QAAA,SAAQ7E,UACC7C,KAAKgI,aAAaN,QAAQ7E,EAAS7C,KAAK4C,WAGjD+E,UAAA,SACEyB,EACAvG,UAEO7C,KAAKgI,aACTL,UAAUyB,EAAmBvG,EAAS7C,KAAK4C,QAC3C0B,MAAM/D,MAGX4H,MAAA,wBAEMnI,KAAK4C,OAAOD,oBAAYgC,EAAeC,gBAAfyE,EAAwB1G,SAC3CwB,QAAQC,QAAQpE,KAAKkJ,cAAcI,MAGrCtJ,KAAKgI,aAAaG,WAAMpG,EAAW/B,KAAK4C,QAAQ0B,MAAM/D,MAGvD6H,cAAR,YAEIpI,KAAK4C,OAAOkC,eACPwC,SACHtH,KAAK4C,OAAO2G,UAAYvJ,KAAKkJ,cAAcM,iBACvC5G,OAAO6C,gBAAyD,IAAvCzF,KAAKgI,aAAayB,UAAUhK,aAEtD0I,WAIDU,mBAAR,0BACMxI,SAICqJ,qBAED1J,KAAKsH,SAAY3F,EAAe3B,KAAK4C,OAAOqD,iBAI1C0D,EAAcC,KAAKC,MAAQ7J,KAAKkJ,cAAcY,UAC9CC,EAAiB/J,KAAK4C,OAAOqD,UAAY0D,EAAc,EACvDK,EAAUjE,KAAKkE,IAAIF,EAAgB,QAEpCG,eAAiB3F,YAAW,WAC1B4F,EAAK7C,UACR6C,EAAK7C,SAAU,EACf6C,EAAKC,eACLD,EAAKjD,OAAO,CAAEa,UAAU,EAAMsC,iBAAiB,OAEhDL,OAGGjB,sBAAR,sBACM1I,SAICiK,uBAEAtK,KAAK4C,OAAOkC,SAAYnD,EAAe3B,KAAK4C,OAAOkG,wBAInDyB,kBAAoBC,aAAY,YAC/BC,EAAK7H,OAAO8H,6BAA+B7I,MAC7C4I,EAAKtC,UAENnI,KAAK4C,OAAOkG,sBAGjBT,aAAA,gBACOQ,0BACAE,2BAGPT,YAAA,gBACOoB,yBACAY,0BAGCZ,kBAAR,WACM1J,KAAKkK,iBACPS,aAAa3K,KAAKkK,qBACbA,oBAAiBnI,MAIlBuI,qBAAR,WACMtK,KAAKuK,oBACPK,cAAc5K,KAAKuK,wBACdA,uBAAoBxI,MAIrBqI,aAAR,iBACUS,EAAU7K,KAAKgI,aAAf6C,MACFvB,EAA4BuB,EAA5BvB,KAAM/F,EAAsBsH,EAAtBtH,OAAQuG,EAAce,EAAdf,UAChBgB,GAAiB,EACjBC,GAAoB,KAItB/K,KAAK4C,OAAOoI,kBACZH,EAAMI,yBACNjL,KAAKkL,4BAALC,EAA0BzH,aAE1B4F,EAAOtJ,KAAKkL,oBAAoB5B,KAChCQ,EAAY9J,KAAKkL,oBAAoBpB,UACrCvG,EAASvD,KAAKkL,oBAAoB3H,OAClCuH,GAAiB,GAGJ,YAAXvH,GAAwBvD,KAAK4C,OAAOwI,gBAAiB,KACjDA,EACmC,mBAAhCpL,KAAK4C,OAAOwI,gBACdpL,KAAK4C,OAAOwI,kBACbpL,KAAK4C,OAAOwI,qBAEa,IAApBA,IACT7H,EAAStD,EAAY0D,QACrB2F,EAAO8B,EACPL,GAAoB,QAInB7B,mBACA5F,EAAeC,IAClB8H,aAAcR,EAAMQ,aACpBlC,MAAOnJ,KAAKwH,OACZ8B,KAAAA,EACA5I,MAAOmK,EAAMnK,MACb4K,aAAcT,EAAMS,aACpB3D,UAAW3H,KAAK2H,UAChB6B,UAAWqB,EAAMU,YAAc,EAC/BC,oBAAqBX,EAAMU,YAAcvL,KAAKuH,mBAC9CkE,WAAYZ,EAAMY,WAClBC,eAAgBb,EAAMa,eACtBT,cAAeJ,EAAMI,cACrBH,eAAAA,EACAC,kBAAAA,EACAzD,QAAStH,KAAKsH,QACdI,QAAS1H,KAAK0H,QACdF,OAAQxH,KAAKwH,OACbsC,UAAAA,OAIIjC,YAAR,eACQjF,EAAS5C,KAAK4C,OACd8F,EAAY1I,KAAKgI,aAEnB2D,EAAQ/I,EAAO0D,WAAWsF,eAC5BhJ,EAAOyC,WAGJsG,IACHA,EAAQ/I,EAAO0D,WAAWuF,YAAYjJ,IAGpC+I,IAAUjD,SAITwC,oBAAsBlL,KAAKkJ,mBAC3BlB,aAAe2D,OACfpE,mBAAqBoE,EAAMd,MAAMU,YAGlCI,EAAMd,MAAMI,cACVrI,EAAOoI,kBAAoBtC,OACxBpB,SAAU,EACyB,mBAAxB1E,EAAOkJ,kBAClBxE,QAAU1E,EAAOkJ,eACkB,kBAAxBlJ,EAAOkJ,kBAClBxE,QAAU1E,EAAOkJ,kBAEjBxE,aAAsC,IAArBqE,EAAMd,MAAMvB,UAG/BhC,QAAUqE,EAAMI,cAAcnJ,EAAOqD,gBAGvCmE,eAEDpK,KAAK+H,iBACPW,GAAAA,EAAWH,oBAAoBvI,WAC1BgI,aAAaC,kBAAkBjI,WAIxCgM,cAAA,SAAcC,OACJrJ,EAAW5C,KAAX4C,OACAsJ,EAASD,EAATC,KAGK,IAATA,GAAuB,IAATA,GAAuB,IAATA,SACzB5E,QAAUtH,KAAKgI,aAAa+D,cAAcnJ,EAAOqD,gBAIlDkG,EAAanM,KAAKkJ,mBACnBkB,mBACClB,EAAgBlJ,KAAKkJ,iBAGd,IAATgD,GAAuB,IAATA,GAAuB,IAATA,QACzB7D,eAIM,IAAT6D,GAAchD,EAAc5B,UAAY6E,EAAW7E,aAKjD8E,EAA+B,GAExB,IAATF,EACFE,EAAcC,WAAY,EACR,IAATH,IACTE,EAAcE,SAAU,IAKxB1J,EAAOmC,sBAEPmE,EAAcI,OAAS6C,EAAW7C,MAClCJ,EAAcxI,QAAUyL,EAAWzL,SAEnC0L,EAAcrE,UAAW,QAGtBb,OAAOkF,OAGNlF,OAAR,SAAerE,OACLD,EAAkD5C,KAAlD4C,OAAQsG,EAA0ClJ,KAA1CkJ,cAAelB,EAA2BhI,KAA3BgI,aAAcD,EAAa/H,KAAb+H,SACrCsE,EAAkCzJ,EAAlCyJ,UAAWE,EAAuB3J,EAAvB2J,UAAWD,EAAY1J,EAAZ0J,QAE9B1F,EAAcG,OAAM,WAEdlE,EAAQwJ,WACNA,GACFzF,EAAcK,UAAS,WACrBoF,EAAUnD,EAAcI,SAGxBiD,GACF3F,EAAcK,UAAS,WACrBsF,EAAUrD,EAAcI,KAAO,UAG1BzG,EAAQyJ,UACbA,GACF1F,EAAcK,UAAS,WACrBqF,EAAQpD,EAAcxI,UAGtB6L,GACF3F,EAAcK,UAAS,WACrBsF,OAAUxK,EAAWmH,EAAcxI,WAMrCmC,EAAQkF,UAAYA,GACtBnB,EAAcK,UAAS,WACrBc,EAASmB,MAKTrG,EAAQwH,iBACVzH,EAAO0D,WAAWkG,sBAAsBxE,YCoLzC,SAASyE,6BAjgBT,WAAuBrL,EAAOsL,OAC/BA,SACGtL,GAASA,EAAMiD,KAAOjD,EAAMiD,QAAeF,QAAQC,UAgcrD,WAAiBuI,EAAMtI,OACzB3C,EAASiL,WACTjL,GAAUA,EAAO2C,KACb3C,EAAO2C,KAAKA,GAEbA,EAAK3C,GAldN,WAAgBN,EAAOiD,EAAMqI,UAC/BA,EACIrI,EAAOA,EAAKjD,GAASA,GAExBA,GAAUA,EAAMiD,OACpBjD,EAAQ+C,QAAQC,QAAQhD,IAElBiD,EAAOjD,EAAMiD,KAAKA,GAAQjD,GAud3B,WAAgBuL,EAAMC,WAEvBlL,EAASiL,IACZ,MAAME,UACAD,EAAQC,UAEZnL,GAAUA,EAAO2C,KACb3C,EAAO2C,UAAK,EAAQuI,GAErBlL,EArfD,WAAgBoL,UACf,eACD,IAAIC,EAAO,GAAIxN,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAChDwN,EAAKxN,GAAKC,UAAUD,cAGb4E,QAAQC,QAAQ0I,EAAE/M,MAAMC,KAAM+M,IACpC,MAAMF,UACA1I,QAAQa,OAAO6H,SAyBZG,wBAeCpK,QACLA,OAASA,OACTF,SAAWE,EAAOF,cAClB2C,UAAYzC,EAAOyC,eACnBiB,WAAa1D,EAAO0D,gBACpBzB,UAAYjC,EAAOiC,eACnB4E,UAAY,QACZoB,MAmfT,SACEjI,OAEM0G,EAC0B,mBAAvB1G,EAAOqK,YACTrK,EAAOqK,cACRrK,EAAOqK,YAEP1J,OACY,IAAT+F,EACHrJ,EAAY0D,QACZf,EAAOkC,QACP7E,EAAYwD,QACZxD,EAAY4D,WAEX,CACLwH,aAAc6B,EAAatK,EAAQ0G,GACnCA,KAAAA,EACA5I,MAAO,KACP4K,aAAc,EACdG,WAAYlI,IAAWtD,EAAYwD,QACnCiI,gBAAgB,EAChBT,eAAe,EACfkC,eAAe,EACf5J,OAAAA,EACAgI,YAAa,EACbzB,UAAWF,KAAKC,OA7gBHuD,CAAgBxK,QACxByK,wCAGC7E,aAAR,SAAqB5F,QACdA,OAASA,OACTiC,UAAYkB,KAAKkE,IAAIjK,KAAK6E,UAAWjC,EAAOiC,cAG3CyI,SAAR,SAAiBrB,mBACVpB,MAugBF,SACLA,EACAoB,gBAEQA,EAAOC,WACRqB,cAEE1C,GACHS,aAAcT,EAAMS,aAAe,SAElCiC,cAEE1C,GACHS,aAAc,EACdG,YAAY,EACZC,eAAgBO,EAAOP,iBAAkB,EACzCnI,YACwB,IAAfsH,EAAMvB,KACTrJ,EAAY0D,QACZ1D,EAAYwD,eAEjB8J,cAEE1C,GACHQ,aAAcY,EAAOZ,aACrB/B,KAAM2C,EAAO3C,KACb5I,MAAO,KACP4K,aAAc,EACdG,YAAY,EACZC,gBAAgB,EAChBT,eAAe,EACfkC,eAAe,EACf5J,OAAQtD,EAAY0D,QACpB4H,YAAaV,EAAMU,YAAc,EACjCzB,mBAAWmC,EAAOnC,aAAaF,KAAKC,aAEnC0D,cAEE1C,GACHnK,MAAOuL,EAAOvL,MACd4K,aAAcT,EAAMS,aAAe,EACnCG,YAAY,EACZC,gBAAgB,EAChBnI,OAAQtD,EAAYoB,MACpBmM,sBAAsB,EACtBjC,YAAaV,EAAMU,YAAc,SAEhCgC,cAEE1C,GACHsC,eAAe,mBAGVtC,GA5jBI4C,CAAazN,KAAK6K,MAAOoB,GAEtCrF,EAAcG,OAAM,WAClBoD,EAAKV,UAAUrC,SAAQ,SAAAsG,GACrBA,EAAS1B,cAAcC,MAGzB9B,EAAK7D,WAAWkG,sBAAsBrC,SAIlCkD,WAAR,sBACMhN,SAICsN,iBAED3N,KAAKyJ,UAAUhK,OAAS,IAAMkC,EAAe3B,KAAK6E,kBAIjD+I,UAAYrJ,YAAW,WAC1BkG,EAAKjD,WACJxH,KAAK6E,gBAGVgJ,OAAA,SAAO1N,OACC2N,EAAU9N,KAAK8N,eAEjBA,GAAW9N,KAAK+N,kBACbA,YAAY5N,GACV2N,EAAQzJ,KAAK9D,GAAM+D,MAAM/D,IAG3B4D,QAAQC,aAAQrC,MAGjBiM,SAAR,+BACOC,gCAGCC,qBAAR,gBACOzE,UAAUrC,SAAQ,SAAAsG,GACrBA,EAASpF,oBAILqF,eAAR,WACM3N,KAAK4N,YACPjD,aAAa3K,KAAK4N,gBACbA,eAAY7L,MAIrBoM,QAAA,SACEnN,EACA6B,WAEMuL,EAAWpO,KAAK6K,MAAMvB,KAGxBA,EAA4BvI,EAAiBC,EAASoN,qBAGjDxL,QAAOyL,oBAAZC,SAA0BF,EAAU9E,IACtCA,EAAO8E,EACEpO,KAAK4C,OAAOsD,oBAErBoD,EJhDC,SAASiF,EAAiBC,EAAQC,MACnCD,IAAMC,SACDD,MAGHE,EAAQvJ,MAAMC,QAAQoJ,IAAMrJ,MAAMC,QAAQqJ,MAE5CC,GAAUpN,EAAckN,IAAMlN,EAAcmN,GAAK,SAC7CE,EAAQD,EAAQF,EAAE/O,OAASL,OAAOmC,KAAKiN,GAAG/O,OAC1CmP,EAASF,EAAQD,EAAIrP,OAAOmC,KAAKkN,GACjCI,EAAQD,EAAOnP,OACfqP,EAAYJ,EAAQ,GAAK,GAE3BK,EAAa,EAERxP,EAAI,EAAGA,EAAIsP,EAAOtP,IAAK,KACxBI,EAAM+O,EAAQnP,EAAIqP,EAAOrP,GAC/BuP,EAAKnP,GAAO4O,EAAiBC,EAAE7O,GAAM8O,EAAE9O,IACnCmP,EAAKnP,KAAS6O,EAAE7O,IAClBoP,WAIGJ,IAAUE,GAASE,IAAeJ,EAAQH,EAAIM,SAGhDL,EIsBIF,CAAiBH,EAAU9E,QAI9B+B,EAAe6B,EAAalN,KAAK4C,OAAQ0G,QAG1CgE,SAAS,CACZpB,KAAMqB,EACNjE,KAAAA,EACA+B,aAAAA,EACAvB,gBAAWjH,SAAAA,EAASiH,eAOxBX,MAAA,WACE3I,EAAQG,KACN,8EAEG6G,YAGPA,OAAA,gBACOlB,WAAW0I,YAAYhP,SAG9BiP,QAAA,gBACOtB,sBACAO,4BACAL,YAGPqB,SAAA,kBACSlP,KAAKyJ,UAAU0F,MAAK,SAAAzB,UAAYA,EAAS9K,OAAOkC,cAGzDwC,QAAA,kBAEItH,KAAK6K,MAAMsC,eACXnN,KAAK6K,MAAMtH,SAAWtD,EAAY0D,SAClC3D,KAAKyJ,UAAU0F,MAAK,SAAAzB,UAAYA,EAASzE,mBAAmB3B,cAIhEyE,cAAA,SAAc9F,mBAAAA,IAAAA,EAAY,GAEtBjG,KAAK6K,MAAMsC,eACXnN,KAAK6K,MAAMtH,SAAWtD,EAAY0D,SAClC3D,KAAK6K,MAAMf,UAAY7D,GAAa2D,KAAKC,SAI7CuF,cAAA,SAAclD,OAGNmD,EAAgBrP,KAAKyJ,UAAU6F,MAAK,SAAA5B,OAChC9K,EAAW8K,EAAX9K,OACA0E,EAAYoG,EAASzE,mBAArB3B,eAEN1E,EAAOkC,UACI,UAAToH,IACiC,WAAhCtJ,EAAO+C,sBACL/C,EAAO+C,sBAAwB2B,IACxB,WAAT4E,IACgC,WAA9BtJ,EAAO8C,oBACL9C,EAAO8C,oBAAsB4B,OAIpC+H,GACFA,EAAclH,aAIX6F,cAMPlG,UAAA,SACEC,OAEM2F,EAAW,IAAIrG,EAAcrH,KAAK4C,eACxC8K,EAAS5F,UAAUC,GACZ2F,KAGTzF,kBAAA,SAAkByF,QACXjE,UAAUtC,KAAKuG,QAGfC,oBAGPpF,oBAAA,SAAoBmF,QACbjE,UAAYzJ,KAAKyJ,UAAU8F,QAAO,SAAAC,UAAKA,IAAM9B,KAE7C1N,KAAKyJ,UAAUhK,SAGdO,KAAKyP,4BACF5B,cAGFR,iBAITqC,WAAA,WACO1P,KAAK6K,MAAMsC,oBACTG,SAAS,CAAEpB,KAAMqB,OAO1B7F,QAAA,SACE7E,EACAD,OAEIkL,EAAwC9N,KAAKmI,WAAMpG,EAAWa,gBAE7DC,SAAAA,EAAS8M,gBACZ7B,EAAUA,EAAQxJ,MAAM/D,IAGnBuN,KAMTnG,UAAA,SACEyB,EACAvG,EACAD,UAEO5C,KAAKmI,MACV,CACER,UAAW,CACTyB,kBAAAA,EACAwG,gBAAU/M,SAAAA,EAAS+M,YAAY,IAGnChN,MAIEuF,eACJtF,EACAD,kBAEI5C,6BAAA6P,EAAK/B,qBACHjL,SAAAA,EAAS8E,YAAakI,EAAKhF,MAAMvB,OAE7BuG,EAAKhC,QAAO,UAGXgC,EAAK/B,sCAKZlL,KACG4F,aAAa5F,OAMd2M,GAHN3M,EAASiN,EAAKjN,QAGQkN,oBAChBC,EAASR,EAASA,EAAOM,EAAKnN,UAAYmN,EAAKnN,kBAEhDoL,QAAUkC,uCAEP1G,8BAEA1G,EAAOqN,WACIJ,EAAKK,mBAAmBtN,EAAQmN,EAAQlN,gBAArDyG,SAEauG,EAAKM,WAAWvN,EAAQmN,EAAQlN,gBAA7CyG,8BAIG6E,QAAQ7E,UAGNuG,EAAK/B,QAGLxE,iBACA5I,SAED2C,EAAiB3C,IAAUA,EAAMP,UAChCmN,SAAS,CACZpB,KAAMqB,EACN7M,MAAAA,IAKC2C,EAAiB3C,IACpBF,EAAQE,MAAMA,UAITmP,EAAK/B,QAGNpN,OApCKsP,GAwCRH,EAAK/B,iDAGNqC,WAAR,SACEvN,EACAmN,EACAK,UAMKpQ,KAAK6K,MAAMY,iBACT6B,SAAS,CAAEpB,KAAMqB,IAIjBvN,KAAKqQ,aAAazN,GARP,kBAAMA,EAAOD,cAAPC,EAAkBmN,SAWpCG,mBAAR,SACEtN,EACAmN,EACAlN,OAEM8E,QAAY9E,SAAAA,EAAS8E,YACaA,GAAa,GAA7CiI,IAAAA,SAAUxG,IAAAA,kBACZsC,IAAiB/D,IAAaiI,EAAW,WAAa,QACtDU,EAAwBtQ,KAAK6K,MAAMvB,MAAgB,GAGnDiH,cACJC,EACAC,EACAC,OAEMC,EAAWC,EAAYJ,EAAOC,eAGhB,IAAXC,QACa,IAAbC,GACP/N,EAAOiO,eAEPH,EAAS9N,EAAOiO,aAAaF,EAAUH,IAGpC7H,QAAQ+H,SAA+B,IAAbC,IAIZ/N,EAAOD,cAAPC,EAAkBmN,UAAQW,eAAvCI,UAECL,GAAWK,UAASN,aAAaA,GAAOM,OALtCN,YAyBRxQ,KAAK6K,MAAMY,YACZzL,KAAK6K,MAAMa,iBAAmBA,QAEzB4B,SAAS,CAAEpB,KAAMqB,EAAkB7B,eAAAA,IAInC1L,KAAKqQ,aAAazN,GAvBP,cACZ8I,SACK6E,EAAUD,EAAWV,EAAUxG,GACjC,GAAKkH,EAAU7Q,OAEf,SACDqO,EAAUyC,EAAU,IACfhR,EAAI,EAAGA,EAAI+Q,EAAU7Q,OAAQF,IACpCuO,EAAUA,EAAQzJ,KAAKkM,UAElBzC,SANAyC,EAAU,UAsBfF,aAAR,SACEzN,EACAmB,qBAEO,IAAII,SAAW,SAAC4M,EAAcC,OAE/BC,EACAC,EAFAC,GAAW,EAITC,EAAO,WACXD,GAAW,SAEJE,EAAKtD,mBACLsD,EAAKpD,qBACLoD,EAAK5B,4BAGZwB,GAAAA,KAQIjM,EAAS,SAAC5D,GACdgQ,IACAJ,EAAY5P,IAIdiQ,EAAKtD,YAAc,SAAA5N,GACjB6E,EAAO,IAAI9E,EAAeC,UAC1B+Q,GAAAA,KAIFG,EAAKpD,cAAgB,iBACnBgD,GAAAA,SAIIK,yCJ1UiBlQ,EI6UbmQ,EAAiBxN,UJ5UC,0BADL3C,EIgVFmQ,UJ/UXnQ,EAAOyM,UIgVXqD,EAAkB,eAEdK,EAAe1D,SACf,YAEJwD,EAAK5B,uBAAwB,KAIjB8B,gBAtCF,SAACnQ,GACfgQ,IACAL,EAAa3P,GAoCXgD,mBACO1D,OAEHyQ,OJjVQnH,EIsVJsB,EAAiB+F,EAAKxG,MAAtBS,aACA1F,EAAsBhD,EAAtBgD,MAAOC,EAAejD,EAAfiD,eAGH,IAAVD,GACA0F,EAAe1F,GACG,mBAAVA,GAAwBA,EAAM0F,EAAc5K,UAStD2Q,EAAK/D,SAAS,CAAEpB,KAAMqB,OJrWVvD,EIwWAjJ,EAAiB8E,EAAYyF,IAAiB,EJvW3D,IAAInH,SAAQ,SAAAC,GACjBG,WAAWH,EAAS4F,4CIyWTnI,MAAwBK,aACrB,IAAIiC,SAAQ,SAAAqN,GAChBP,EAAeO,oBAKdL,GACHG,UAnBAtM,EAAOtE,UAyBb4Q,aAKN,SAASV,EAAqBJ,EAAkBZ,UACvCA,EAAWY,EAAM,GAAKA,EAAMA,EAAM/Q,OAAS,GAGpD,SAASyN,EACPtK,EACA4N,EACAZ,MAEIhN,EAAOqN,UAAYrN,EAAOiO,cAAgB1L,MAAMC,QAAQoL,UACnD7H,QAAQ/F,EAAOiO,aAAaD,EAAYJ,EAAOZ,GAAWY,QCzhBxDiB,wBAQC7O,QACLA,OAASA,GAAU,QACnByH,gBAAkB,QAClBzF,QAAU,QACV8M,aAAe,QACfjG,WAAa,6BAGpBe,sBAAA,SAAsBb,mBACfF,WAAazL,KAAK2R,aAAalQ,QAClC,SAACmQ,EAAKC,UAAOA,EAAEhH,MAAMY,WAAamG,EAAM,EAAIA,IAC5C,GAGFhL,EAAcG,OAAM,WAClBoD,EAAKE,gBAAgBjD,SAAQ,SAAAW,GAC3BnB,EAAcK,UAAS,WACrBc,EAASoC,EAAMwB,eAMvBlF,iBAAA,kBACSzG,KAAK4C,OAAOkP,iBAGrBzL,uBAAA,SACE3D,EACAE,UAEOyD,EAAuBrG,KAAM0C,OAAUX,EAAWa,MAG3DkF,UAAA,SAAUC,0BACHsC,gBAAgBlD,KAAKY,GACnB,WACL0C,EAAKJ,gBAAkBI,EAAKJ,gBAAgBkF,QAAO,SAAAC,UAAKA,IAAMzH,SAIlEoB,MAAA,SAAMtG,QACCkP,uBACDlP,SAAAA,EAASqE,cACNsF,2BAITmF,WAAA,SACEK,EACAnP,OAQIoP,EANEC,GAAuB,IAAdF,QAA2C,IAAdA,KAExCE,IAAWrP,SACN7C,KAAK0R,gBAKW,mBAAdM,EACTC,EAAcD,MACT,OAC4BnP,GAAW,GAApCsP,IAAAA,MAAOC,IAAAA,OAAQC,IAAAA,MACjB3L,EAAiB1G,KAAKqG,uBAAuB2L,GAEnDC,EAAc,SAAAtG,OAEPuG,KACCC,MAEExG,EAAMtG,YAAcqB,EAAerB,iBAC9B,WLjFd,SAASiN,EAAa9D,EAAQC,UAC/BD,IAAMC,UAICD,UAAaC,IAIP,iBAAND,IACDpP,OAAOmC,KAAKkN,GAAGU,MAAK,SAAAxP,UAAQ2S,EAAa9D,EAAE7O,GAAM8O,EAAE9O,QK2E9C2S,CAAa3G,EAAMjJ,SAAUgE,EAAehE,iBACxC,SAMS,kBAAX0P,GAAwBzG,EAAMuD,aAAekD,KAKnC,kBAAVC,GAAuB1G,EAAMrE,YAAc+K,WAQnDrS,KAAK0R,aAAanC,OAAO0C,MAGlCM,SAAA,SACEP,UAEOhS,KAAK2R,WAA4BK,EAAW,CAAEG,OAAO,IAAQ,MAGtEvG,eAAA,SACEvG,UAEOrF,KAAK4E,QAAQS,MAGtBmN,aAAA,SAAsBR,yBACbhS,KAAKuS,SAAkBP,WAAvBS,EAAmC5H,MAAMvB,QAGlD0F,YAAA,SAAYrD,GACN3L,KAAK4E,QAAQ+G,EAAMtG,aACrBsG,EAAMsD,iBACCjP,KAAK4E,QAAQ+G,EAAMtG,gBACrBqM,aAAe1R,KAAK0R,aAAanC,QAAO,SAAAC,UAAKA,IAAM7D,UACnDa,sBAAsBb,OAI/BoG,cAAA,SACEC,EACAnP,mBAEK8O,WAAWK,EAAWnP,GAASuE,SAAQ,SAAAuE,GAC1C+G,EAAK1D,YAAYrD,SAIrBgH,cAAA,SACEX,EACAnP,QAEK8O,WAAWK,EAAWnP,GAASuE,SAAQ,SAAAuE,GAC1CA,EAAMkC,eAOV+E,kBAAA,SACEZ,EACAnP,OAEM+B,EAAU5E,KAAK2R,WAAWK,EAAWnP,GAE3C+D,EAAcG,OAAM,WAClBnC,EAAQwC,SAAQ,SAAAuE,GACdA,EAAM+D,yBAIgD7M,GAAW,OAA7DgQ,cAAAA,oBAAsBC,gBAAAA,oBAEzBA,IAAoBD,SAChB1O,QAAQC,QAAQQ,OAGnBmO,OAA6ClQ,GAE/CgQ,IAAkBC,EACpBC,EAAeX,QAAS,EACfU,IAAoBD,IAC7BE,EAAeX,QAAS,OAGtBtE,EAAU9N,KAAKgT,eAAehB,EAAWe,gBAExClQ,SAAAA,EAAS8M,gBACZ7B,EAAUA,EAAQxJ,OAAM,kBAAMM,MAGzBkJ,EAAQzJ,MAAK,kBAAMO,QAM5BoO,eAAA,SACEhB,EACAnP,cAEMoQ,EAA+C,UAErDrM,EAAcG,OAAM,WAClB8I,EAAK8B,WAAWK,EAAWnP,GAASuE,SAAQ,SAAAuE,OACtCmC,EAAUnC,EAAMxD,QAAQ9D,MAAK,kBAAMsH,YAElC9I,SAAAA,EAAS8M,gBACZ7B,EAAUA,EAAQxJ,OAAM,kBAAMqH,MAGhCsH,EAAS9L,KAAK2G,SAIX3J,QAAQ+O,IAAID,MAGrBE,qBAAA,gBACOxB,aAAavK,SAAQ,SAAAuE,GACxBA,EAAMd,MAAM2C,sBAAuB,QAIvC4F,WAAA,SACE1Q,EACAE,OAEM8D,EAAiB1G,KAAKqG,uBAAuB3D,EAAUE,GACzD+I,EAAQ3L,KAAK4L,eAAgClF,EAAerB,kBAE3DsG,IACHA,EAAQ3L,KAAK6L,YAAYnF,IAGpBiF,KAGTE,YAAA,SACEjJ,OAEM+I,EAAQ,IAAIqB,EAAMpK,UAGnB5C,KAAK4C,OAAOyQ,cACVzO,QAAQ+G,EAAMtG,WAAasG,OAC3B+F,aAAavK,KAAKwE,QAClBa,sBAAsBb,IAGtBA,KA4BT2H,WAAA,SACEhR,EACAC,EACAC,SAE2BH,EAA8BC,EAAMC,EAAMC,GAA9DE,OAAUE,OAEX8D,EAAiB1G,KAAKqG,uBAAuB3D,KAEjDkD,OAAO,GACJhD,IAGD+I,EAAQ3L,KAAK4L,eAAgClF,EAAerB,kBAE3DsG,IACHA,EAAQ3L,KAAK6L,YAAYnF,IAGtBiF,EAAMI,cAAcnJ,EAAOqD,WAIzB0F,EAAMxD,WAAMpG,EAAW2E,GAHrBvC,QAAQC,QAAQuH,EAAMd,MAAMvB,SA8CvCiK,cAAA,SACEjR,EACAC,EACAC,EACAC,GAGEnB,EAAciB,KACbA,EAAK1C,eAAe,iBAAmB0C,EAAK1C,eAAe,YAE5D4C,EAAOF,EACPA,OAAOR,EACPS,OAAOT,SAG2BM,EAIlCC,EAAMC,EAAMC,EAAMC,GAJbC,OAAUE,OAAQC,cAMrBA,SAAAA,EAAS2Q,SACX5Q,EAAOqD,UAAY,OAGjB6H,EAAwC9N,KAAKsT,WAC/C5Q,EACAE,gBAGGC,SAAAA,EAAS8M,gBACZ7B,EAAUA,EAAQxJ,MAAM/D,IAGnBuN,KAuBT2F,WAAA,SACEnR,EACAC,EACAC,SAE2BH,EAA8BC,EAAMC,EAAMC,GAA9DE,OAAUE,OACX8D,EAAiB1G,KAAKqG,uBAAuB3D,EAAUE,UACtD,IAAIyE,EAAcX,MAG3BgN,aAAA,SACEhR,EACA1B,EACA4B,QAEKwQ,WAAW1Q,EAAUE,GAAQuL,QAAQnN,SAIxC2S,EAAoB,IAAIlC,EAAW,CAAE4B,OAAQhT,IAEtCuT,EAAc,CAACD,GAKrB,SAASE,EAAejR,UACtB,IAAI6O,EAAW7O,GAGjB,SAASkR,EAA2B5H,GACrCrK,KAAuBK,KACzB0E,EAAcG,OAAM,WAClB6M,EAAYxM,SAAQ,SAAAd,GAClBA,EAAWqL,aAAavK,SAAQ,SAAAuE,GAC9BA,EAAMyD,cAAclD,gBC9fjB6H,EAAkBjQ,GAAiB,kBAC9CgQ,EAA2B,YAG7BC,GAAgB,SAAAC,aACV3T,aAAaC,eAAA2T,EAAQC,yBAKzB5T,OAAO4T,iBAAiB,mBAAoBF,GAAa,GACzD1T,OAAO4T,iBAAiB,QAASF,GAAa,GAEvC,WAEL1T,OAAO6T,oBAAoB,mBAAoBH,GAC/C1T,OAAO6T,oBAAoB,QAASH,WChB3BI,EAAmBtQ,GAAiB,kBAC/CgQ,EAA2B,aAG7BM,GAAiB,SAAAC,aACXhU,aAAaC,eAAA2T,EAAQC,yBAKzB5T,OAAO4T,iBAAiB,SAAUG,GAAc,GAEzC,WAEL/T,OAAO6T,oBAAoB,SAAUE,OChBlC,IAAMC,EAA0BC,EAASD,wBCO1CE,EAAoBC,EAAMC,cAAcf,GAEjCgB,GAAgB,kBAAMF,EAAMG,WAAWJ,IAMvCK,GAAkE,gBAC7EvO,IAAAA,WACAwO,IAAAA,SAEMC,EAAqBN,EAAMO,SAC/B,kBAAM1O,GAAc,IAAImL,IACxB,CAACnL,WAGHmO,EAAMQ,WAAU,kBACdrB,EAAYzM,KAAK4N,GAEV,eAECxV,EAAIqU,EAAYsB,QAAQH,GAC1BxV,GAAK,GACPqU,EAAYuB,OAAO5V,EAAG,GAGN,MAAd+G,GACFyO,EAAmB5L,MAAM,CAAEjC,QAAQ,OAGtC,CAAC6N,EAAoBzO,IAGtBmO,gBAACD,EAAkBY,UAAShU,MAAO2T,GAChCD,ICtCDO,GAAgBZ,EAAMC,mBAC1B3S,GAGK,SAASuT,YACPb,EAAMG,WAAWS,QAObE,GAAoE,gBAC/E3S,IAAAA,OACAkS,IAAAA,SAEMU,EAAeF,KAEfG,EAAehB,EAAMO,SACzB,kBACEQ,GToDJ/G,ESpDwD7L,ETsDjD,CACL+D,aAJF6H,ESnD0CgH,GTwDjC7O,OACF8H,EAAE9H,QAEP/B,aACK4J,EAAE5J,QACF6J,EAAE7J,SAEPwB,eACKoI,EAAEpI,UACFqI,EAAErI,aSjEyDxD,ETkD7D,IACL4L,EACAC,ISnDE,CAAC7L,EAAQ4S,WAITf,gBAACY,GAAcD,UAAShU,MAAOqU,GAC5BX,ICrBP,SAASY,SACHC,GAAU,QACP,CACLC,WAAY,WACVD,GAAU,GAEZE,MAAO,WACLF,GAAU,GAEZA,QAAS,kBACAA,IAKb,IAAMG,GAAUrB,EAAMC,cAAcgB,MAIvBK,GAAwB,kBAAMtB,EAAMG,WAAWkB,KAU/CE,GAA4E,gBACvFlB,IAAAA,SAEM1T,EAAQqT,EAAMO,SAAQ,kBAAMU,OAAe,WAE/CjB,gBAACqB,GAAQV,UAAShU,MAAOA,GACF,mBAAb0T,EACHA,EAAsB1T,GACvB0T,IC3CH,SAASmB,SACRC,EAAazB,EAAM0B,QAAO,GAC1BC,EAAY3B,EAAM4B,aAAY,kBAAMH,EAAWI,UAAS,WAE9D7B,EAAMpU,EAAW,YAAc,oBAAmB,kBAChD6V,EAAWI,SAAU,EACd,WACLJ,EAAWI,SAAU,KAEtB,IAEIF,ECVF,SAASG,SACRH,EAAYH,KACZ3P,EAAaqO,OACiBF,EAAM+B,SAASlQ,EAAWmF,YAAvDA,OAAYgL,cAEnBhC,EAAMQ,WACJ,kBACE3O,EAAWwB,WAAU,WACfsO,KACFK,EAAcnQ,EAAWmF,iBAG/B,CAACnF,EAAYmQ,EAAeL,IAGvB3K,ECgEF,SAASiL,GAAOtV,EAAOiD,EAAMqI,UAC/BA,EACIrI,EAAOA,EAAKjD,GAASA,GAExBA,GAAUA,EAAMiD,OACpBjD,EAAQ+C,QAAQC,QAAQhD,IAElBiD,EAAOjD,EAAMiD,KAAKA,GAAQjD,2BA5BlC,SAASgM,iBAEF9J,EAAerD,EAAY4D,OAC9ByF,UAAMvH,EACNrB,MAAO,OAIX,SAASiW,GACP9L,EACAoB,UAEQA,EAAOC,WACRqB,UACIH,UACJG,eAEEjK,EAAerD,EAAYwD,UAC9B6F,UAAMvH,EACNrB,MAAO,YAEN6M,eAEEjK,EAAerD,EAAY0D,UAC9B2F,KAAM2C,EAAO3C,KACb5I,MAAO,YAEN6M,eAEEjK,EAAerD,EAAYoB,QAC9BiI,UAAMvH,EACNrB,MAAOuL,EAAOvL,uBAGTmK,GAIN,SAAS+L,GAMdC,EACAjU,YAAAA,IAAAA,EAAiE,QF1FZqB,EAC/CmS,EE+FA1P,EbaD,SAMLJ,EACAC,EACA3D,OAEM4D,EAAmBF,EAAWG,+BAE/B9B,EAAeyB,gBACfI,SAAAA,EAAkBG,aAClBH,SAAAA,EAAkBJ,gBAClBG,SAAAA,EAAeI,aACfJ,SAAAA,EAAeH,UACfxD,Ga9BkBkU,CAJTnC,KACQW,KAGiD1S,KAEvC6R,EAAMsC,WACpCJ,GACA,KACAvJ,IAHKvC,OAAOmM,OAKR1J,GFvG+CrJ,EEuGjB+S,EFtG9BZ,EAAYH,KACVxB,EAAM4B,aACZ,cACMD,WACKnS,4BAGX,CAACA,EAAUmS,KEiGPa,EAAoBxC,EAAM0B,SAC1Be,EAAsBzC,EAAM0B,OAAOU,GACzCK,EAAoBZ,QAAUO,MACxBM,EAAkB1C,EAAM0B,OAAOzP,GACrCyQ,EAAgBb,QAAU5P,MAzDLoG,EA2DfsK,EAAS3C,EAAM4B,aA3DAvJ,WA6DjBuK,EACAC,YAAAA,IAAAA,EAAqE,QAE/DC,EAAeJ,EAAgBb,QAE/BkB,EdvGHpX,IcwGH6W,EAAkBX,QAAUkB,MAIxBC,EAFEC,EAAW,kBAAMT,EAAkBX,UAAYkB,UAuapD,SAAgB7K,EAAMC,WAEvBlL,EAASiL,IACZ,MAAME,UACAD,EAAQC,UAEZnL,GAAUA,EAAO2C,KACb3C,EAAO2C,UAAK,EAAQuI,GAErBlL,sBA3aA4L,EAAS,CAAEpB,KAAMqB,cACMgK,EAAaI,gBAAbJ,EAAaI,SAAWN,uBAA/CI,QAGmBG,EADMV,EAAoBZ,SACTe,aAA9B/N,UAEFoO,KACFpK,EAAS,CAAEpB,KAAMqB,GAAoBjE,KAAAA,aAGjCiO,EAAalL,iBAAbkL,EAAalL,UAAY/C,EAAM+N,+BAC/BC,EAAajL,iBAAbiL,EAAajL,UAAY/C,EAAM+N,+BAC/BE,EAAahL,iBAAbgL,EAAahL,UAAYjD,EAAM,KAAM+N,+BACrCC,EAAa/K,iBAAb+K,EAAa/K,UAAYjD,EAAM,KAAM+N,sBAEpC/N,gCACA5I,UACPF,EAAQE,MAAMA,YACR6W,EAAajL,eAAbiL,EAAajL,QAAU5L,EAAO2W,EAAYI,+BAC1CH,EAAahL,eAAbgL,EAAahL,QAAU5L,EAAO2W,EAAYI,+BAC1CF,EAAahL,iBAAbgL,EAAahL,eACjBxK,EACArB,EACA2W,EACAI,+BAEIH,EAAa/K,iBAAb+K,EAAa/K,eACjBxK,EACArB,EACA2W,EACAI,kBAGEC,KACFpK,EAAS,CAAEpB,KAAMqB,GAAmB7M,MAAAA,IAGlC4W,EAAa3H,cAAgB4H,EAAa5H,mBACtCjP,kBA/GR,eACD,IAAIqM,EAAO,GAAIxN,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAChDwN,EAAKxN,GAAKC,UAAUD,cAGb4E,QAAQC,QAAQ0I,EAAE/M,MAAMC,KAAM+M,IACpC,MAAMF,UACA1I,QAAQa,OAAO6H,MA4GrB,CAACS,IAGHmH,EAAMQ,WAAU,eACRsC,EAAeJ,EAAgBb,QAC7B/M,EAA+BgO,EAA/BhO,aAA+BgO,EAArBM,kBACOtO,IAAasB,EAAMnK,YACpCmK,EAAMnK,QAEb,CAACmK,EAAMnK,YAEJmV,EAAQpB,EAAM4B,aAAY,WAC9B/I,EAAS,CAAEpB,KAAMqB,OAChB,CAACD,UAOG,CAAC8J,OAJHvM,GACHgL,MAAAA,KCjMG,SAASiC,GACdpV,EACAE,OAESmV,EAAYtD,EAAMsC,YAAW,SAAAjW,UAAKA,EAAI,IAAG,MAC5CsV,EAAYH,KACZ+B,EAAQrD,KACRpO,EAAgB+O,KAChB2C,EAAqBlC,KAGrBrP,EAAiBL,EACrB2R,EACAtV,EACA6D,EACA3D,GAIIsV,EAAczD,EAAM0B,SACpBgC,GAAeD,EAAY5B,QAC3B5I,EAAWwK,EAAY5B,SAAW,IAAIjP,EAAcX,GAC1DwR,EAAY5B,QAAU5I,EAGtB+G,EAAMQ,WAAU,kBACdgD,EAAmBrC,aACZlI,EAAS5F,WAAU,WACpBsO,KACF2B,SAGH,CAAC3B,EAAW1I,EAAUqK,EAAUE,IAG9BE,GACHzK,EAASlF,aAAa9B,OAGlBhF,EAASgM,EAASzE,sBAGpBvC,EAAe6C,UAAY7C,EAAemR,iBAAkB,KACxDlM,EAAQ+B,EAAS1E,qBAGrBtH,EAAO0B,UACN6U,EAAmBtC,WACpBhK,EAAMd,MAAM2C,2BAEN9L,EAAOhB,SAIbgG,EAAe5B,SACf4B,EAAe6C,WACd7H,EAAOgC,UACR,CACAuU,EAAmBrC,iBACbhO,EAAc8F,EAAS5F,kBACvB4F,EAASvF,QAAQiQ,QAAQxQ,WAI5BlG,EC3BF,SAAS2W,GACd/V,EACAC,EACAC,SAE2BH,EAA8BC,EAAMC,EAAMC,UAC9DsV,cCEF,SAASQ,GACdhW,EACAC,EACAC,SAE2BH,EAA8BC,EAAMC,EAAMC,GAC/Dd,EAASoW,WACb9M,kBAAkB,sBAIftJ,GACH6W,aAAc7W,EAAO4H,KACrBkP,WAAY9W,EAAOoJ,oBAAiB/I,EAAYL,EAAO4H,OClBpD,SAASmP,GACdnW,EACAC,EACAC,SAE2BH,EAAgCC,EAAMC,EAAMC,UAChEsV,mBAAoC7H,UAAU,KCtDvDxL,EAAkB6P"}
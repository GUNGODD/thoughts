{"version":3,"file":"react-query-hydration.mjs","sources":["../../src/hydration/hydration.ts","../../src/hydration/react.tsx"],"sourcesContent":["import type { Query, QueryCache, QueryKey } from 'react-query'\n\nexport interface DehydratedQueryConfig {\n  cacheTime?: number\n}\n\nexport interface DehydratedQuery {\n  queryKey: QueryKey\n  data?: unknown\n  updatedAt: number\n  config: DehydratedQueryConfig\n}\n\nexport interface DehydratedState {\n  queries: Array<DehydratedQuery>\n}\n\nexport type ShouldDehydrateFunction = <TResult, TError = unknown>(\n  query: Query<TResult, TError>\n) => boolean\n\nexport interface DehydrateConfig {\n  shouldDehydrate?: ShouldDehydrateFunction\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery<TResult, TError = unknown>(\n  query: Query<TResult, TError>\n): DehydratedQuery {\n  return {\n    config: {\n      cacheTime: query.cacheTime,\n    },\n    data: query.state.data,\n    queryKey: query.queryKey,\n    updatedAt: query.state.updatedAt,\n  }\n}\n\nfunction defaultShouldDehydrate<TResult, TError>(\n  query: Query<TResult, TError>\n) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  queryCache: QueryCache,\n  dehydrateConfig?: DehydrateConfig\n): DehydratedState {\n  const config = dehydrateConfig || {}\n  const shouldDehydrate = config.shouldDehydrate || defaultShouldDehydrate\n  const queries: DehydratedQuery[] = []\n\n  queryCache.getQueries().forEach(query => {\n    if (shouldDehydrate(query)) {\n      queries.push(dehydrateQuery(query))\n    }\n  })\n\n  return { queries }\n}\n\nexport function hydrate(\n  queryCache: QueryCache,\n  dehydratedState: unknown\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  queries.forEach(dehydratedQuery => {\n    const resolvedConfig = queryCache.getResolvedQueryConfig(\n      dehydratedQuery.queryKey,\n      dehydratedQuery.config\n    )\n\n    let query = queryCache.getQueryByHash(resolvedConfig.queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query && query.state.updatedAt >= dehydratedQuery.updatedAt) {\n      return\n    }\n\n    if (!query) {\n      query = queryCache.createQuery(resolvedConfig)\n    }\n\n    query.setData(dehydratedQuery.data, {\n      updatedAt: dehydratedQuery.updatedAt,\n    })\n  })\n}\n","import React from 'react'\nimport { useQueryCache } from 'react-query'\n\nimport { hydrate } from './hydration'\n\nexport function useHydrate(queries: unknown) {\n  const queryCache = useQueryCache()\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization\n  React.useMemo(() => {\n    if (queries) {\n      hydrate(queryCache, queries)\n    }\n    return undefined\n  }, [queryCache, queries])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n}\n\nexport const Hydrate: React.FC<HydrateProps> = ({ state, children }) => {\n  useHydrate(state)\n  return children as React.ReactElement<any>\n}\n"],"names":["dehydrateQuery","query","config","cacheTime","data","state","queryKey","updatedAt","defaultShouldDehydrate","status","dehydrate","queryCache","dehydrateConfig","shouldDehydrate","queries","getQueries","forEach","push","hydrate","dehydratedState","dehydratedQuery","resolvedConfig","getResolvedQueryConfig","getQueryByHash","queryHash","createQuery","setData","useHydrate","useQueryCache","React","useMemo","undefined","Hydrate","children"],"mappings":";;;AAyBA;AACA;AACA;AACA;AACA,SAASA,cAAT,CACEC,KADF,EAEmB;AACjB,SAAO;AACLC,IAAAA,MAAM,EAAE;AACNC,MAAAA,SAAS,EAAEF,KAAK,CAACE;AADX,KADH;AAILC,IAAAA,IAAI,EAAEH,KAAK,CAACI,KAAN,CAAYD,IAJb;AAKLE,IAAAA,QAAQ,EAAEL,KAAK,CAACK,QALX;AAMLC,IAAAA,SAAS,EAAEN,KAAK,CAACI,KAAN,CAAYE;AANlB,GAAP;AAQD;;AAED,SAASC,sBAAT,CACEP,KADF,EAEE;AACA,SAAOA,KAAK,CAACI,KAAN,CAAYI,MAAZ,KAAuB,SAA9B;AACD;;AAEM,SAASC,SAAT,CACLC,UADK,EAELC,eAFK,EAGY;AACjB,MAAMV,MAAM,GAAGU,eAAe,IAAI,EAAlC;AACA,MAAMC,eAAe,GAAGX,MAAM,CAACW,eAAP,IAA0BL,sBAAlD;AACA,MAAMM,OAA0B,GAAG,EAAnC;AAEAH,EAAAA,UAAU,CAACI,UAAX,GAAwBC,OAAxB,CAAgC,UAAAf,KAAK,EAAI;AACvC,QAAIY,eAAe,CAACZ,KAAD,CAAnB,EAA4B;AAC1Ba,MAAAA,OAAO,CAACG,IAAR,CAAajB,cAAc,CAACC,KAAD,CAA3B;AACD;AACF,GAJD;AAMA,SAAO;AAAEa,IAAAA,OAAO,EAAPA;AAAF,GAAP;AACD;AAEM,SAASI,OAAT,CACLP,UADK,EAELQ,eAFK,EAGC;AACN,MAAI,OAAOA,eAAP,KAA2B,QAA3B,IAAuCA,eAAe,KAAK,IAA/D,EAAqE;AACnE;AACD;;AAED,MAAML,OAAO,GAAIK,eAAD,CAAqCL,OAArC,IAAgD,EAAhE;AAEAA,EAAAA,OAAO,CAACE,OAAR,CAAgB,UAAAI,eAAe,EAAI;AACjC,QAAMC,cAAc,GAAGV,UAAU,CAACW,sBAAX,CACrBF,eAAe,CAACd,QADK,EAErBc,eAAe,CAAClB,MAFK,CAAvB;AAKA,QAAID,KAAK,GAAGU,UAAU,CAACY,cAAX,CAA0BF,cAAc,CAACG,SAAzC,CAAZ,CANiC;;AASjC,QAAIvB,KAAK,IAAIA,KAAK,CAACI,KAAN,CAAYE,SAAZ,IAAyBa,eAAe,CAACb,SAAtD,EAAiE;AAC/D;AACD;;AAED,QAAI,CAACN,KAAL,EAAY;AACVA,MAAAA,KAAK,GAAGU,UAAU,CAACc,WAAX,CAAuBJ,cAAvB,CAAR;AACD;;AAEDpB,IAAAA,KAAK,CAACyB,OAAN,CAAcN,eAAe,CAAChB,IAA9B,EAAoC;AAClCG,MAAAA,SAAS,EAAEa,eAAe,CAACb;AADO,KAApC;AAGD,GApBD;AAqBD;;AC3FM,SAASoB,UAAT,CAAoBb,OAApB,EAAsC;AAC3C,MAAMH,UAAU,GAAGiB,aAAa,EAAhC,CAD2C;AAI3C;AACA;;AACAC,EAAAA,KAAK,CAACC,OAAN,CAAc,YAAM;AAClB,QAAIhB,OAAJ,EAAa;AACXI,MAAAA,OAAO,CAACP,UAAD,EAAaG,OAAb,CAAP;AACD;;AACD,WAAOiB,SAAP;AACD,GALD,EAKG,CAACpB,UAAD,EAAaG,OAAb,CALH;AAMD;IAMYkB,OAA+B,GAAG,SAAlCA,OAAkC,OAAyB;AAAA,MAAtB3B,KAAsB,QAAtBA,KAAsB;AAAA,MAAf4B,QAAe,QAAfA,QAAe;AACtEN,EAAAA,UAAU,CAACtB,KAAD,CAAV;AACA,SAAO4B,QAAP;AACD;;;;"}
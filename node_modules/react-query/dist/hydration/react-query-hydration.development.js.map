{"version":3,"file":"react-query-hydration.development.js","sources":["../../src/hydration/hydration.ts","../../src/hydration/react.tsx"],"sourcesContent":["import type { Query, QueryCache, QueryKey } from 'react-query'\n\nexport interface DehydratedQueryConfig {\n  cacheTime?: number\n}\n\nexport interface DehydratedQuery {\n  queryKey: QueryKey\n  data?: unknown\n  updatedAt: number\n  config: DehydratedQueryConfig\n}\n\nexport interface DehydratedState {\n  queries: Array<DehydratedQuery>\n}\n\nexport type ShouldDehydrateFunction = <TResult, TError = unknown>(\n  query: Query<TResult, TError>\n) => boolean\n\nexport interface DehydrateConfig {\n  shouldDehydrate?: ShouldDehydrateFunction\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery<TResult, TError = unknown>(\n  query: Query<TResult, TError>\n): DehydratedQuery {\n  return {\n    config: {\n      cacheTime: query.cacheTime,\n    },\n    data: query.state.data,\n    queryKey: query.queryKey,\n    updatedAt: query.state.updatedAt,\n  }\n}\n\nfunction defaultShouldDehydrate<TResult, TError>(\n  query: Query<TResult, TError>\n) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  queryCache: QueryCache,\n  dehydrateConfig?: DehydrateConfig\n): DehydratedState {\n  const config = dehydrateConfig || {}\n  const shouldDehydrate = config.shouldDehydrate || defaultShouldDehydrate\n  const queries: DehydratedQuery[] = []\n\n  queryCache.getQueries().forEach(query => {\n    if (shouldDehydrate(query)) {\n      queries.push(dehydrateQuery(query))\n    }\n  })\n\n  return { queries }\n}\n\nexport function hydrate(\n  queryCache: QueryCache,\n  dehydratedState: unknown\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  queries.forEach(dehydratedQuery => {\n    const resolvedConfig = queryCache.getResolvedQueryConfig(\n      dehydratedQuery.queryKey,\n      dehydratedQuery.config\n    )\n\n    let query = queryCache.getQueryByHash(resolvedConfig.queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query && query.state.updatedAt >= dehydratedQuery.updatedAt) {\n      return\n    }\n\n    if (!query) {\n      query = queryCache.createQuery(resolvedConfig)\n    }\n\n    query.setData(dehydratedQuery.data, {\n      updatedAt: dehydratedQuery.updatedAt,\n    })\n  })\n}\n","import React from 'react'\nimport { useQueryCache } from 'react-query'\n\nimport { hydrate } from './hydration'\n\nexport function useHydrate(queries: unknown) {\n  const queryCache = useQueryCache()\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization\n  React.useMemo(() => {\n    if (queries) {\n      hydrate(queryCache, queries)\n    }\n    return undefined\n  }, [queryCache, queries])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n}\n\nexport const Hydrate: React.FC<HydrateProps> = ({ state, children }) => {\n  useHydrate(state)\n  return children as React.ReactElement<any>\n}\n"],"names":["dehydrateQuery","query","config","cacheTime","data","state","queryKey","updatedAt","defaultShouldDehydrate","status","dehydrate","queryCache","dehydrateConfig","shouldDehydrate","queries","getQueries","forEach","push","hydrate","dehydratedState","dehydratedQuery","resolvedConfig","getResolvedQueryConfig","getQueryByHash","queryHash","createQuery","setData","useHydrate","useQueryCache","React","useMemo","undefined","Hydrate","children"],"mappings":";;;;;;;;EAyBA;EACA;EACA;EACA;EACA,SAASA,cAAT,CACEC,KADF,EAEmB;EACjB,SAAO;EACLC,IAAAA,MAAM,EAAE;EACNC,MAAAA,SAAS,EAAEF,KAAK,CAACE;EADX,KADH;EAILC,IAAAA,IAAI,EAAEH,KAAK,CAACI,KAAN,CAAYD,IAJb;EAKLE,IAAAA,QAAQ,EAAEL,KAAK,CAACK,QALX;EAMLC,IAAAA,SAAS,EAAEN,KAAK,CAACI,KAAN,CAAYE;EANlB,GAAP;EAQD;;EAED,SAASC,sBAAT,CACEP,KADF,EAEE;EACA,SAAOA,KAAK,CAACI,KAAN,CAAYI,MAAZ,KAAuB,SAA9B;EACD;;EAEM,SAASC,SAAT,CACLC,UADK,EAELC,eAFK,EAGY;EACjB,MAAMV,MAAM,GAAGU,eAAe,IAAI,EAAlC;EACA,MAAMC,eAAe,GAAGX,MAAM,CAACW,eAAP,IAA0BL,sBAAlD;EACA,MAAMM,OAA0B,GAAG,EAAnC;EAEAH,EAAAA,UAAU,CAACI,UAAX,GAAwBC,OAAxB,CAAgC,UAAAf,KAAK,EAAI;EACvC,QAAIY,eAAe,CAACZ,KAAD,CAAnB,EAA4B;EAC1Ba,MAAAA,OAAO,CAACG,IAAR,CAAajB,cAAc,CAACC,KAAD,CAA3B;EACD;EACF,GAJD;EAMA,SAAO;EAAEa,IAAAA,OAAO,EAAPA;EAAF,GAAP;EACD;EAEM,SAASI,OAAT,CACLP,UADK,EAELQ,eAFK,EAGC;EACN,MAAI,OAAOA,eAAP,KAA2B,QAA3B,IAAuCA,eAAe,KAAK,IAA/D,EAAqE;EACnE;EACD;;EAED,MAAML,OAAO,GAAIK,eAAD,CAAqCL,OAArC,IAAgD,EAAhE;EAEAA,EAAAA,OAAO,CAACE,OAAR,CAAgB,UAAAI,eAAe,EAAI;EACjC,QAAMC,cAAc,GAAGV,UAAU,CAACW,sBAAX,CACrBF,eAAe,CAACd,QADK,EAErBc,eAAe,CAAClB,MAFK,CAAvB;EAKA,QAAID,KAAK,GAAGU,UAAU,CAACY,cAAX,CAA0BF,cAAc,CAACG,SAAzC,CAAZ,CANiC;;EASjC,QAAIvB,KAAK,IAAIA,KAAK,CAACI,KAAN,CAAYE,SAAZ,IAAyBa,eAAe,CAACb,SAAtD,EAAiE;EAC/D;EACD;;EAED,QAAI,CAACN,KAAL,EAAY;EACVA,MAAAA,KAAK,GAAGU,UAAU,CAACc,WAAX,CAAuBJ,cAAvB,CAAR;EACD;;EAEDpB,IAAAA,KAAK,CAACyB,OAAN,CAAcN,eAAe,CAAChB,IAA9B,EAAoC;EAClCG,MAAAA,SAAS,EAAEa,eAAe,CAACb;EADO,KAApC;EAGD,GApBD;EAqBD;;EC3FM,SAASoB,UAAT,CAAoBb,OAApB,EAAsC;EAC3C,MAAMH,UAAU,GAAGiB,wBAAa,EAAhC,CAD2C;EAI3C;EACA;;EACAC,EAAAA,KAAK,CAACC,OAAN,CAAc,YAAM;EAClB,QAAIhB,OAAJ,EAAa;EACXI,MAAAA,OAAO,CAACP,UAAD,EAAaG,OAAb,CAAP;EACD;;EACD,WAAOiB,SAAP;EACD,GALD,EAKG,CAACpB,UAAD,EAAaG,OAAb,CALH;EAMD;MAMYkB,OAA+B,GAAG,SAAlCA,OAAkC,OAAyB;EAAA,MAAtB3B,KAAsB,QAAtBA,KAAsB;EAAA,MAAf4B,QAAe,QAAfA,QAAe;EACtEN,EAAAA,UAAU,CAACtB,KAAD,CAAV;EACA,SAAO4B,QAAP;EACD;;;;;;;;;;;;;;;"}